-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Object.User exposing (..)

import Api.Enum.Post_select_column
import Api.Enum.Post_tag_select_column
import Api.Enum.Tag_select_column
import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalars
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


email : SelectionSet String Api.Object.User
email =
    Object.selectionForField "String" "email" [] Decode.string


id : SelectionSet CustomScalars.Uuid Api.Object.User
id =
    Object.selectionForField "CustomScalars.Uuid" "id" [] (CustomScalars.codecs |> Api.Scalar.unwrapCodecs |> .codecUuid |> .decoder)


nonce : SelectionSet String Api.Object.User
nonce =
    Object.selectionForField "String" "nonce" [] Decode.string


password : SelectionSet String Api.Object.User
password =
    Object.selectionForField "String" "password" [] Decode.string


type alias PostTagsByuserIdOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_tag_select_column.Post_tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_tag_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
postTagsByuserId : (PostTagsByuserIdOptionalArguments -> PostTagsByuserIdOptionalArguments) -> SelectionSet decodesTo Api.Object.Post_tag -> SelectionSet (List decodesTo) Api.Object.User
postTagsByuserId fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_tag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_tag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "postTagsByuserId" optionalArgs object_ (identity >> Decode.list)


type alias PostTagsByuserIdAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_tag_select_column.Post_tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_tag_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
postTagsByuserId_aggregate : (PostTagsByuserIdAggregateOptionalArguments -> PostTagsByuserIdAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.Post_tag_aggregate -> SelectionSet decodesTo Api.Object.User
postTagsByuserId_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_tag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_tag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "postTagsByuserId_aggregate" optionalArgs object_ identity


type alias PostsByuserIdOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_select_column.Post_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
postsByuserId : (PostsByuserIdOptionalArguments -> PostsByuserIdOptionalArguments) -> SelectionSet decodesTo Api.Object.Post -> SelectionSet (List decodesTo) Api.Object.User
postsByuserId fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "postsByuserId" optionalArgs object_ (identity >> Decode.list)


type alias PostsByuserIdAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_select_column.Post_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
postsByuserId_aggregate : (PostsByuserIdAggregateOptionalArguments -> PostsByuserIdAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.Post_aggregate -> SelectionSet decodesTo Api.Object.User
postsByuserId_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "postsByuserId_aggregate" optionalArgs object_ identity


type alias TagsByuserIdOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Tag_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tagsByuserId : (TagsByuserIdOptionalArguments -> TagsByuserIdOptionalArguments) -> SelectionSet decodesTo Api.Object.Tag -> SelectionSet (List decodesTo) Api.Object.User
tagsByuserId fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeTag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tagsByuserId" optionalArgs object_ (identity >> Decode.list)


type alias TagsByuserIdAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Tag_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tagsByuserId_aggregate : (TagsByuserIdAggregateOptionalArguments -> TagsByuserIdAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.Tag_aggregate -> SelectionSet decodesTo Api.Object.User
tagsByuserId_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeTag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tagsByuserId_aggregate" optionalArgs object_ identity
