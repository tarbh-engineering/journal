-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Mutation exposing (..)

import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalars
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DeletePostRequiredArguments =
    { where_ : Api.InputObject.Post_bool_exp }


{-| delete data from the table: "post"

  - where\_ - filter the rows which have to be deleted

-}
delete_post : DeletePostRequiredArguments -> SelectionSet decodesTo Api.Object.Post_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_post requiredArgs object_ =
    Object.selectionForCompositeField "delete_post" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodePost_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeletePostByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| delete single row from the table: "post"
-}
delete_post_by_pk : DeletePostByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Post -> SelectionSet (Maybe decodesTo) RootMutation
delete_post_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "delete_post_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias DeletePostTagRequiredArguments =
    { where_ : Api.InputObject.Post_tag_bool_exp }


{-| delete data from the table: "post\_tag"

  - where\_ - filter the rows which have to be deleted

-}
delete_post_tag : DeletePostTagRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_post_tag requiredArgs object_ =
    Object.selectionForCompositeField "delete_post_tag" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodePost_tag_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeletePostTagByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| delete single row from the table: "post\_tag"
-}
delete_post_tag_by_pk : DeletePostTagByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag -> SelectionSet (Maybe decodesTo) RootMutation
delete_post_tag_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "delete_post_tag_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias DeleteTagRequiredArguments =
    { where_ : Api.InputObject.Tag_bool_exp }


{-| delete data from the table: "tag"

  - where\_ - filter the rows which have to be deleted

-}
delete_tag : DeleteTagRequiredArguments -> SelectionSet decodesTo Api.Object.Tag_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_tag requiredArgs object_ =
    Object.selectionForCompositeField "delete_tag" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeTag_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteTagByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| delete single row from the table: "tag"
-}
delete_tag_by_pk : DeleteTagByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Tag -> SelectionSet (Maybe decodesTo) RootMutation
delete_tag_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "delete_tag_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias DeleteUserRequiredArguments =
    { where_ : Api.InputObject.User_bool_exp }


{-| delete data from the table: "user"

  - where\_ - filter the rows which have to be deleted

-}
delete_user : DeleteUserRequiredArguments -> SelectionSet decodesTo Api.Object.User_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_user requiredArgs object_ =
    Object.selectionForCompositeField "delete_user" [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeUser_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteUserByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| delete single row from the table: "user"
-}
delete_user_by_pk : DeleteUserByPkRequiredArguments -> SelectionSet decodesTo Api.Object.User -> SelectionSet (Maybe decodesTo) RootMutation
delete_user_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "delete_user_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias InsertPostOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Post_on_conflict }


type alias InsertPostRequiredArguments =
    { objects : List Api.InputObject.Post_insert_input }


{-| insert data into the table: "post"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_post : (InsertPostOptionalArguments -> InsertPostOptionalArguments) -> InsertPostRequiredArguments -> SelectionSet decodesTo Api.Object.Post_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_post fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodePost_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_post" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodePost_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertPostOneOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Post_on_conflict }


type alias InsertPostOneRequiredArguments =
    { object : Api.InputObject.Post_insert_input }


{-| insert a single row into the table: "post"

  - object - the row to be inserted
  - on\_conflict - on conflict condition

-}
insert_post_one : (InsertPostOneOptionalArguments -> InsertPostOneOptionalArguments) -> InsertPostOneRequiredArguments -> SelectionSet decodesTo Api.Object.Post -> SelectionSet (Maybe decodesTo) RootMutation
insert_post_one fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodePost_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_post_one" (optionalArgs ++ [ Argument.required "object" requiredArgs.object Api.InputObject.encodePost_insert_input ]) object_ (identity >> Decode.nullable)


type alias InsertPostTagOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Post_tag_on_conflict }


type alias InsertPostTagRequiredArguments =
    { objects : List Api.InputObject.Post_tag_insert_input }


{-| insert data into the table: "post\_tag"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_post_tag : (InsertPostTagOptionalArguments -> InsertPostTagOptionalArguments) -> InsertPostTagRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_post_tag fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodePost_tag_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_post_tag" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodePost_tag_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertPostTagOneOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Post_tag_on_conflict }


type alias InsertPostTagOneRequiredArguments =
    { object : Api.InputObject.Post_tag_insert_input }


{-| insert a single row into the table: "post\_tag"

  - object - the row to be inserted
  - on\_conflict - on conflict condition

-}
insert_post_tag_one : (InsertPostTagOneOptionalArguments -> InsertPostTagOneOptionalArguments) -> InsertPostTagOneRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag -> SelectionSet (Maybe decodesTo) RootMutation
insert_post_tag_one fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodePost_tag_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_post_tag_one" (optionalArgs ++ [ Argument.required "object" requiredArgs.object Api.InputObject.encodePost_tag_insert_input ]) object_ (identity >> Decode.nullable)


type alias InsertTagOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Tag_on_conflict }


type alias InsertTagRequiredArguments =
    { objects : List Api.InputObject.Tag_insert_input }


{-| insert data into the table: "tag"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_tag : (InsertTagOptionalArguments -> InsertTagOptionalArguments) -> InsertTagRequiredArguments -> SelectionSet decodesTo Api.Object.Tag_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_tag fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeTag_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_tag" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodeTag_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertTagOneOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.Tag_on_conflict }


type alias InsertTagOneRequiredArguments =
    { object : Api.InputObject.Tag_insert_input }


{-| insert a single row into the table: "tag"

  - object - the row to be inserted
  - on\_conflict - on conflict condition

-}
insert_tag_one : (InsertTagOneOptionalArguments -> InsertTagOneOptionalArguments) -> InsertTagOneRequiredArguments -> SelectionSet decodesTo Api.Object.Tag -> SelectionSet (Maybe decodesTo) RootMutation
insert_tag_one fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeTag_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_tag_one" (optionalArgs ++ [ Argument.required "object" requiredArgs.object Api.InputObject.encodeTag_insert_input ]) object_ (identity >> Decode.nullable)


type alias InsertUserOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.User_on_conflict }


type alias InsertUserRequiredArguments =
    { objects : List Api.InputObject.User_insert_input }


{-| insert data into the table: "user"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_user : (InsertUserOptionalArguments -> InsertUserOptionalArguments) -> InsertUserRequiredArguments -> SelectionSet decodesTo Api.Object.User_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_user fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeUser_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_user" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Api.InputObject.encodeUser_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertUserOneOptionalArguments =
    { on_conflict : OptionalArgument Api.InputObject.User_on_conflict }


type alias InsertUserOneRequiredArguments =
    { object : Api.InputObject.User_insert_input }


{-| insert a single row into the table: "user"

  - object - the row to be inserted
  - on\_conflict - on conflict condition

-}
insert_user_one : (InsertUserOneOptionalArguments -> InsertUserOneOptionalArguments) -> InsertUserOneRequiredArguments -> SelectionSet decodesTo Api.Object.User -> SelectionSet (Maybe decodesTo) RootMutation
insert_user_one fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Api.InputObject.encodeUser_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_user_one" (optionalArgs ++ [ Argument.required "object" requiredArgs.object Api.InputObject.encodeUser_insert_input ]) object_ (identity >> Decode.nullable)


type alias LoginRequiredArguments =
    { email : String
    , password : String
    }


login : LoginRequiredArguments -> SelectionSet String RootMutation
login requiredArgs =
    Object.selectionForField "String" "login" [ Argument.required "email" requiredArgs.email Encode.string, Argument.required "password" requiredArgs.password Encode.string ] Decode.string


type alias SignupRequiredArguments =
    { email : String
    , nonce : String
    , password : String
    }


signup : SignupRequiredArguments -> SelectionSet String RootMutation
signup requiredArgs =
    Object.selectionForField "String" "signup" [ Argument.required "email" requiredArgs.email Encode.string, Argument.required "nonce" requiredArgs.nonce Encode.string, Argument.required "password" requiredArgs.password Encode.string ] Decode.string


type alias UpdatePostOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.Post_set_input }


type alias UpdatePostRequiredArguments =
    { where_ : Api.InputObject.Post_bool_exp }


{-| update data of the table: "post"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_post : (UpdatePostOptionalArguments -> UpdatePostOptionalArguments) -> UpdatePostRequiredArguments -> SelectionSet decodesTo Api.Object.Post_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_post fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodePost_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_post" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodePost_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdatePostByPkOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.Post_set_input }


type alias UpdatePostByPkRequiredArguments =
    { pk_columns : Api.InputObject.Post_pk_columns_input }


{-| update single row of the table: "post"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_post_by_pk : (UpdatePostByPkOptionalArguments -> UpdatePostByPkOptionalArguments) -> UpdatePostByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Post -> SelectionSet (Maybe decodesTo) RootMutation
update_post_by_pk fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodePost_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_post_by_pk" (optionalArgs ++ [ Argument.required "pk_columns" requiredArgs.pk_columns Api.InputObject.encodePost_pk_columns_input ]) object_ (identity >> Decode.nullable)


type alias UpdatePostTagOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.Post_tag_set_input }


type alias UpdatePostTagRequiredArguments =
    { where_ : Api.InputObject.Post_tag_bool_exp }


{-| update data of the table: "post\_tag"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_post_tag : (UpdatePostTagOptionalArguments -> UpdatePostTagOptionalArguments) -> UpdatePostTagRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_post_tag fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodePost_tag_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_post_tag" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodePost_tag_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdatePostTagByPkOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.Post_tag_set_input }


type alias UpdatePostTagByPkRequiredArguments =
    { pk_columns : Api.InputObject.Post_tag_pk_columns_input }


{-| update single row of the table: "post\_tag"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_post_tag_by_pk : (UpdatePostTagByPkOptionalArguments -> UpdatePostTagByPkOptionalArguments) -> UpdatePostTagByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag -> SelectionSet (Maybe decodesTo) RootMutation
update_post_tag_by_pk fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodePost_tag_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_post_tag_by_pk" (optionalArgs ++ [ Argument.required "pk_columns" requiredArgs.pk_columns Api.InputObject.encodePost_tag_pk_columns_input ]) object_ (identity >> Decode.nullable)


type alias UpdateTagOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.Tag_set_input }


type alias UpdateTagRequiredArguments =
    { where_ : Api.InputObject.Tag_bool_exp }


{-| update data of the table: "tag"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_tag : (UpdateTagOptionalArguments -> UpdateTagOptionalArguments) -> UpdateTagRequiredArguments -> SelectionSet decodesTo Api.Object.Tag_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_tag fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeTag_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_tag" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeTag_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateTagByPkOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.Tag_set_input }


type alias UpdateTagByPkRequiredArguments =
    { pk_columns : Api.InputObject.Tag_pk_columns_input }


{-| update single row of the table: "tag"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_tag_by_pk : (UpdateTagByPkOptionalArguments -> UpdateTagByPkOptionalArguments) -> UpdateTagByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Tag -> SelectionSet (Maybe decodesTo) RootMutation
update_tag_by_pk fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeTag_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_tag_by_pk" (optionalArgs ++ [ Argument.required "pk_columns" requiredArgs.pk_columns Api.InputObject.encodeTag_pk_columns_input ]) object_ (identity >> Decode.nullable)


type alias UpdateUserOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.User_set_input }


type alias UpdateUserRequiredArguments =
    { where_ : Api.InputObject.User_bool_exp }


{-| update data of the table: "user"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_user : (UpdateUserOptionalArguments -> UpdateUserOptionalArguments) -> UpdateUserRequiredArguments -> SelectionSet decodesTo Api.Object.User_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_user fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeUser_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_user" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Api.InputObject.encodeUser_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateUserByPkOptionalArguments =
    { set_ : OptionalArgument Api.InputObject.User_set_input }


type alias UpdateUserByPkRequiredArguments =
    { pk_columns : Api.InputObject.User_pk_columns_input }


{-| update single row of the table: "user"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_user_by_pk : (UpdateUserByPkOptionalArguments -> UpdateUserByPkOptionalArguments) -> UpdateUserByPkRequiredArguments -> SelectionSet decodesTo Api.Object.User -> SelectionSet (Maybe decodesTo) RootMutation
update_user_by_pk fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { set_ = Absent }

        optionalArgs =
            [ Argument.optional "_set" filledInOptionals.set_ Api.InputObject.encodeUser_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_user_by_pk" (optionalArgs ++ [ Argument.required "pk_columns" requiredArgs.pk_columns Api.InputObject.encodeUser_pk_columns_input ]) object_ (identity >> Decode.nullable)
