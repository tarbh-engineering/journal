-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Query exposing (..)

import Api.Enum.Post_select_column
import Api.Enum.Post_tag_select_column
import Api.Enum.Tag_select_column
import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalars
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias CheckRequiredArguments =
    { ciph : String }


check :
    CheckRequiredArguments
    -> SelectionSet Bool RootQuery
check requiredArgs =
    Object.selectionForField "Bool" "check" [ Argument.required "ciph" requiredArgs.ciph Encode.string ] Decode.bool


type alias NonceRequiredArguments =
    { email : String }


nonce :
    NonceRequiredArguments
    -> SelectionSet String RootQuery
nonce requiredArgs =
    Object.selectionForField "String" "nonce" [ Argument.required "email" requiredArgs.email Encode.string ] Decode.string


type alias PostOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_select_column.Post_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_bool_exp
    }


{-| fetch data from the table: "post"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
post :
    (PostOptionalArguments -> PostOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Post
    -> SelectionSet (List decodesTo) RootQuery
post fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "post" optionalArgs object_ (identity >> Decode.list)


type alias PostByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "post" using primary key columns
-}
post_by_pk :
    PostByPkRequiredArguments
    -> SelectionSet decodesTo Api.Object.Post
    -> SelectionSet (Maybe decodesTo) RootQuery
post_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "post_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias PostTagOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_tag_select_column.Post_tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_tag_bool_exp
    }


{-| fetch data from the table: "post\_tag"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
post_tag :
    (PostTagOptionalArguments -> PostTagOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Post_tag
    -> SelectionSet (List decodesTo) RootQuery
post_tag fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_tag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_tag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "post_tag" optionalArgs object_ (identity >> Decode.list)


type alias PostTagByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "post\_tag" using primary key columns
-}
post_tag_by_pk :
    PostTagByPkRequiredArguments
    -> SelectionSet decodesTo Api.Object.Post_tag
    -> SelectionSet (Maybe decodesTo) RootQuery
post_tag_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "post_tag_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


refresh : SelectionSet (Maybe CustomScalars.Jwt) RootQuery
refresh =
    Object.selectionForField "(Maybe CustomScalars.Jwt)" "refresh" [] (CustomScalars.codecs |> Api.Scalar.unwrapCodecs |> .codecJwt |> .decoder |> Decode.nullable)


type alias TagOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Tag_bool_exp
    }


{-| fetch data from the table: "tag"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag :
    (TagOptionalArguments -> TagOptionalArguments)
    -> SelectionSet decodesTo Api.Object.Tag
    -> SelectionSet (List decodesTo) RootQuery
tag fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeTag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tag" optionalArgs object_ (identity >> Decode.list)


type alias TagByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "tag" using primary key columns
-}
tag_by_pk :
    TagByPkRequiredArguments
    -> SelectionSet decodesTo Api.Object.Tag
    -> SelectionSet (Maybe decodesTo) RootQuery
tag_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "tag_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)
