-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Query exposing (..)

import Api.Enum.Post_select_column
import Api.Enum.Post_tag_select_column
import Api.Enum.Tag_select_column
import Api.Enum.User_select_column
import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalars
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias NonceRequiredArguments =
    { email : String }


nonce : NonceRequiredArguments -> SelectionSet (Maybe String) RootQuery
nonce requiredArgs =
    Object.selectionForField "(Maybe String)" "nonce" [ Argument.required "email" requiredArgs.email Encode.string ] (Decode.string |> Decode.nullable)


type alias PostOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_select_column.Post_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_bool_exp
    }


{-| fetch data from the table: "post"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
post : (PostOptionalArguments -> PostOptionalArguments) -> SelectionSet decodesTo Api.Object.Post -> SelectionSet (List decodesTo) RootQuery
post fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "post" optionalArgs object_ (identity >> Decode.list)


type alias PostAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_select_column.Post_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_bool_exp
    }


{-| fetch aggregated fields from the table: "post"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
post_aggregate : (PostAggregateOptionalArguments -> PostAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.Post_aggregate -> SelectionSet decodesTo RootQuery
post_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "post_aggregate" optionalArgs object_ identity


type alias PostByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "post" using primary key columns
-}
post_by_pk : PostByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Post -> SelectionSet (Maybe decodesTo) RootQuery
post_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "post_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias PostTagOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_tag_select_column.Post_tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_tag_bool_exp
    }


{-| fetch data from the table: "post\_tag"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
post_tag : (PostTagOptionalArguments -> PostTagOptionalArguments) -> SelectionSet decodesTo Api.Object.Post_tag -> SelectionSet (List decodesTo) RootQuery
post_tag fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_tag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_tag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "post_tag" optionalArgs object_ (identity >> Decode.list)


type alias PostTagAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Post_tag_select_column.Post_tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Post_tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Post_tag_bool_exp
    }


{-| fetch aggregated fields from the table: "post\_tag"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
post_tag_aggregate : (PostTagAggregateOptionalArguments -> PostTagAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.Post_tag_aggregate -> SelectionSet decodesTo RootQuery
post_tag_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Post_tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodePost_tag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodePost_tag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "post_tag_aggregate" optionalArgs object_ identity


type alias PostTagByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "post\_tag" using primary key columns
-}
post_tag_by_pk : PostTagByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Post_tag -> SelectionSet (Maybe decodesTo) RootQuery
post_tag_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "post_tag_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias TagOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Tag_bool_exp
    }


{-| fetch data from the table: "tag"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag : (TagOptionalArguments -> TagOptionalArguments) -> SelectionSet decodesTo Api.Object.Tag -> SelectionSet (List decodesTo) RootQuery
tag fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeTag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tag" optionalArgs object_ (identity >> Decode.list)


type alias TagAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.Tag_order_by)
    , where_ : OptionalArgument Api.InputObject.Tag_bool_exp
    }


{-| fetch aggregated fields from the table: "tag"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag_aggregate : (TagAggregateOptionalArguments -> TagAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.Tag_aggregate -> SelectionSet decodesTo RootQuery
tag_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeTag_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "tag_aggregate" optionalArgs object_ identity


type alias TagByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "tag" using primary key columns
-}
tag_by_pk : TagByPkRequiredArguments -> SelectionSet decodesTo Api.Object.Tag -> SelectionSet (Maybe decodesTo) RootQuery
tag_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "tag_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)


type alias UserOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.User_select_column.User_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.User_order_by)
    , where_ : OptionalArgument Api.InputObject.User_bool_exp
    }


{-| fetch data from the table: "user"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
user : (UserOptionalArguments -> UserOptionalArguments) -> SelectionSet decodesTo Api.Object.User -> SelectionSet (List decodesTo) RootQuery
user fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.User_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeUser_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeUser_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "user" optionalArgs object_ (identity >> Decode.list)


type alias UserAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Api.Enum.User_select_column.User_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Api.InputObject.User_order_by)
    , where_ : OptionalArgument Api.InputObject.User_bool_exp
    }


{-| fetch aggregated fields from the table: "user"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
user_aggregate : (UserAggregateOptionalArguments -> UserAggregateOptionalArguments) -> SelectionSet decodesTo Api.Object.User_aggregate -> SelectionSet decodesTo RootQuery
user_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum Api.Enum.User_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (Api.InputObject.encodeUser_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ Api.InputObject.encodeUser_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "user_aggregate" optionalArgs object_ identity


type alias UserByPkRequiredArguments =
    { id : CustomScalars.Uuid }


{-| fetch data from the table: "user" using primary key columns
-}
user_by_pk : UserByPkRequiredArguments -> SelectionSet decodesTo Api.Object.User -> SelectionSet (Maybe decodesTo) RootQuery
user_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "user_by_pk" [ Argument.required "id" requiredArgs.id (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) ] object_ (identity >> Decode.nullable)
