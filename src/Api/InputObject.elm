-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (..)

import Api.Enum.Order_by
import Api.Enum.Post_constraint
import Api.Enum.Post_tag_constraint
import Api.Enum.Post_tag_update_column
import Api.Enum.Post_update_column
import Api.Enum.Tag_constraint
import Api.Enum.Tag_update_column
import Api.Enum.User_constraint
import Api.Enum.User_update_column
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalars
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildDate_comparison_exp : (Date_comparison_expOptionalFields -> Date_comparison_expOptionalFields) -> Date_comparison_exp
buildDate_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Date_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalars.Date
    , gt_ : OptionalArgument CustomScalars.Date
    , gte_ : OptionalArgument CustomScalars.Date
    , in_ : OptionalArgument (List CustomScalars.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Date
    , lte_ : OptionalArgument CustomScalars.Date
    , neq_ : OptionalArgument CustomScalars.Date
    , nin_ : OptionalArgument (List CustomScalars.Date)
    }


{-| Type for the Date\_comparison\_exp input object.
-}
type alias Date_comparison_exp =
    { eq_ : OptionalArgument CustomScalars.Date
    , gt_ : OptionalArgument CustomScalars.Date
    , gte_ : OptionalArgument CustomScalars.Date
    , in_ : OptionalArgument (List CustomScalars.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Date
    , lte_ : OptionalArgument CustomScalars.Date
    , neq_ : OptionalArgument CustomScalars.Date
    , nin_ : OptionalArgument (List CustomScalars.Date)
    }


{-| Encode a Date\_comparison\_exp into a value that can be used as an argument.
-}
encodeDate_comparison_exp : Date_comparison_exp -> Value
encodeDate_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildPost_aggregate_order_by : (Post_aggregate_order_byOptionalFields -> Post_aggregate_order_byOptionalFields) -> Post_aggregate_order_by
buildPost_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Post_aggregate_order_byOptionalFields =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Post_max_order_by
    , min : OptionalArgument Post_min_order_by
    }


{-| Type for the Post\_aggregate\_order\_by input object.
-}
type alias Post_aggregate_order_by =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Post_max_order_by
    , min : OptionalArgument Post_min_order_by
    }


{-| Encode a Post\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodePost_aggregate_order_by : Post_aggregate_order_by -> Value
encodePost_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodePost_max_order_by |> Encode.optional input.max ), ( "min", encodePost_min_order_by |> Encode.optional input.min ) ]


buildPost_arr_rel_insert_input : Post_arr_rel_insert_inputRequiredFields -> (Post_arr_rel_insert_inputOptionalFields -> Post_arr_rel_insert_inputOptionalFields) -> Post_arr_rel_insert_input
buildPost_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Post_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Post_arr_rel_insert_inputRequiredFields =
    { data : List Post_insert_input }


type alias Post_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Post_on_conflict }


{-| Type alias for the `Post_arr_rel_insert_input` attributes. Note that this type
needs to use the `Post_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_arr_rel_insert_inputRaw =
    { data : List Post_insert_input
    , on_conflict : OptionalArgument Post_on_conflict
    }


{-| Type for the Post\_arr\_rel\_insert\_input input object.
-}
type Post_arr_rel_insert_input
    = Post_arr_rel_insert_input Post_arr_rel_insert_inputRaw


{-| Encode a Post\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_arr_rel_insert_input : Post_arr_rel_insert_input -> Value
encodePost_arr_rel_insert_input (Post_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePost_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodePost_on_conflict |> Encode.optional input.on_conflict ) ]


buildPost_bool_exp : (Post_bool_expOptionalFields -> Post_bool_expOptionalFields) -> Post_bool_exp
buildPost_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, body = Absent, date = Absent, id = Absent, postTagsBypostId = Absent, userByuserId = Absent, user_id = Absent }
    in
    Post_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, body = optionals.body, date = optionals.date, id = optionals.id, postTagsBypostId = optionals.postTagsBypostId, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Post_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Post_bool_exp))
    , not_ : OptionalArgument Post_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_bool_exp))
    , body : OptionalArgument String_comparison_exp
    , date : OptionalArgument Date_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , postTagsBypostId : OptionalArgument Post_tag_bool_exp
    , userByuserId : OptionalArgument User_bool_exp
    , user_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Post_bool_exp` attributes. Note that this type
needs to use the `Post_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Post_bool_exp))
    , not_ : OptionalArgument Post_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_bool_exp))
    , body : OptionalArgument String_comparison_exp
    , date : OptionalArgument Date_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , postTagsBypostId : OptionalArgument Post_tag_bool_exp
    , userByuserId : OptionalArgument User_bool_exp
    , user_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Post\_bool\_exp input object.
-}
type Post_bool_exp
    = Post_bool_exp Post_bool_expRaw


{-| Encode a Post\_bool\_exp into a value that can be used as an argument.
-}
encodePost_bool_exp : Post_bool_exp -> Value
encodePost_bool_exp (Post_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodePost_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePost_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePost_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "body", encodeString_comparison_exp |> Encode.optional input.body ), ( "date", encodeDate_comparison_exp |> Encode.optional input.date ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "postTagsBypostId", encodePost_tag_bool_exp |> Encode.optional input.postTagsBypostId ), ( "userByuserId", encodeUser_bool_exp |> Encode.optional input.userByuserId ), ( "user_id", encodeUuid_comparison_exp |> Encode.optional input.user_id ) ]


buildPost_insert_input : (Post_insert_inputOptionalFields -> Post_insert_inputOptionalFields) -> Post_insert_input
buildPost_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, date = Absent, id = Absent, postTagsBypostId = Absent, userByuserId = Absent, user_id = Absent }
    in
    Post_insert_input { body = optionals.body, date = optionals.date, id = optionals.id, postTagsBypostId = optionals.postTagsBypostId, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Post_insert_inputOptionalFields =
    { body : OptionalArgument String
    , date : OptionalArgument CustomScalars.Date
    , id : OptionalArgument CustomScalars.Uuid
    , postTagsBypostId : OptionalArgument Post_tag_arr_rel_insert_input
    , userByuserId : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type alias for the `Post_insert_input` attributes. Note that this type
needs to use the `Post_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_insert_inputRaw =
    { body : OptionalArgument String
    , date : OptionalArgument CustomScalars.Date
    , id : OptionalArgument CustomScalars.Uuid
    , postTagsBypostId : OptionalArgument Post_tag_arr_rel_insert_input
    , userByuserId : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Post\_insert\_input input object.
-}
type Post_insert_input
    = Post_insert_input Post_insert_inputRaw


{-| Encode a Post\_insert\_input into a value that can be used as an argument.
-}
encodePost_insert_input : Post_insert_input -> Value
encodePost_insert_input (Post_insert_input input) =
    Encode.maybeObject
        [ ( "body", Encode.string |> Encode.optional input.body ), ( "date", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date ), ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "postTagsBypostId", encodePost_tag_arr_rel_insert_input |> Encode.optional input.postTagsBypostId ), ( "userByuserId", encodeUser_obj_rel_insert_input |> Encode.optional input.userByuserId ), ( "user_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.user_id ) ]


buildPost_max_order_by : (Post_max_order_byOptionalFields -> Post_max_order_byOptionalFields) -> Post_max_order_by
buildPost_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, date = Absent, id = Absent, user_id = Absent }
    in
    { body = optionals.body, date = optionals.date, id = optionals.id, user_id = optionals.user_id }


type alias Post_max_order_byOptionalFields =
    { body : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_max\_order\_by input object.
-}
type alias Post_max_order_by =
    { body : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Post\_max\_order\_by into a value that can be used as an argument.
-}
encodePost_max_order_by : Post_max_order_by -> Value
encodePost_max_order_by input =
    Encode.maybeObject
        [ ( "body", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.body ), ( "date", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildPost_min_order_by : (Post_min_order_byOptionalFields -> Post_min_order_byOptionalFields) -> Post_min_order_by
buildPost_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, date = Absent, id = Absent, user_id = Absent }
    in
    { body = optionals.body, date = optionals.date, id = optionals.id, user_id = optionals.user_id }


type alias Post_min_order_byOptionalFields =
    { body : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_min\_order\_by input object.
-}
type alias Post_min_order_by =
    { body : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Post\_min\_order\_by into a value that can be used as an argument.
-}
encodePost_min_order_by : Post_min_order_by -> Value
encodePost_min_order_by input =
    Encode.maybeObject
        [ ( "body", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.body ), ( "date", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildPost_obj_rel_insert_input : Post_obj_rel_insert_inputRequiredFields -> (Post_obj_rel_insert_inputOptionalFields -> Post_obj_rel_insert_inputOptionalFields) -> Post_obj_rel_insert_input
buildPost_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Post_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Post_obj_rel_insert_inputRequiredFields =
    { data : Post_insert_input }


type alias Post_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Post_on_conflict }


{-| Type alias for the `Post_obj_rel_insert_input` attributes. Note that this type
needs to use the `Post_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_obj_rel_insert_inputRaw =
    { data : Post_insert_input
    , on_conflict : OptionalArgument Post_on_conflict
    }


{-| Type for the Post\_obj\_rel\_insert\_input input object.
-}
type Post_obj_rel_insert_input
    = Post_obj_rel_insert_input Post_obj_rel_insert_inputRaw


{-| Encode a Post\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_obj_rel_insert_input : Post_obj_rel_insert_input -> Value
encodePost_obj_rel_insert_input (Post_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePost_insert_input input.data |> Just ), ( "on_conflict", encodePost_on_conflict |> Encode.optional input.on_conflict ) ]


buildPost_on_conflict : Post_on_conflictRequiredFields -> (Post_on_conflictOptionalFields -> Post_on_conflictOptionalFields) -> Post_on_conflict
buildPost_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Post_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Post_on_conflictRequiredFields =
    { constraint : Api.Enum.Post_constraint.Post_constraint
    , update_columns : List Api.Enum.Post_update_column.Post_update_column
    }


type alias Post_on_conflictOptionalFields =
    { where_ : OptionalArgument Post_bool_exp }


{-| Type alias for the `Post_on_conflict` attributes. Note that this type
needs to use the `Post_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_on_conflictRaw =
    { constraint : Api.Enum.Post_constraint.Post_constraint
    , update_columns : List Api.Enum.Post_update_column.Post_update_column
    , where_ : OptionalArgument Post_bool_exp
    }


{-| Type for the Post\_on\_conflict input object.
-}
type Post_on_conflict
    = Post_on_conflict Post_on_conflictRaw


{-| Encode a Post\_on\_conflict into a value that can be used as an argument.
-}
encodePost_on_conflict : Post_on_conflict -> Value
encodePost_on_conflict (Post_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Post_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Post_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodePost_bool_exp |> Encode.optional input.where_ ) ]


buildPost_order_by : (Post_order_byOptionalFields -> Post_order_byOptionalFields) -> Post_order_by
buildPost_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, date = Absent, id = Absent, postTagsBypostId_aggregate = Absent, userByuserId = Absent, user_id = Absent }
    in
    Post_order_by { body = optionals.body, date = optionals.date, id = optionals.id, postTagsBypostId_aggregate = optionals.postTagsBypostId_aggregate, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Post_order_byOptionalFields =
    { body : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , postTagsBypostId_aggregate : OptionalArgument Post_tag_aggregate_order_by
    , userByuserId : OptionalArgument User_order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type alias for the `Post_order_by` attributes. Note that this type
needs to use the `Post_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_order_byRaw =
    { body : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , postTagsBypostId_aggregate : OptionalArgument Post_tag_aggregate_order_by
    , userByuserId : OptionalArgument User_order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_order\_by input object.
-}
type Post_order_by
    = Post_order_by Post_order_byRaw


{-| Encode a Post\_order\_by into a value that can be used as an argument.
-}
encodePost_order_by : Post_order_by -> Value
encodePost_order_by (Post_order_by input) =
    Encode.maybeObject
        [ ( "body", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.body ), ( "date", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "postTagsBypostId_aggregate", encodePost_tag_aggregate_order_by |> Encode.optional input.postTagsBypostId_aggregate ), ( "userByuserId", encodeUser_order_by |> Encode.optional input.userByuserId ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildPost_pk_columns_input : Post_pk_columns_inputRequiredFields -> Post_pk_columns_input
buildPost_pk_columns_input required =
    { id = required.id }


type alias Post_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the Post\_pk\_columns\_input input object.
-}
type alias Post_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a Post\_pk\_columns\_input into a value that can be used as an argument.
-}
encodePost_pk_columns_input : Post_pk_columns_input -> Value
encodePost_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildPost_set_input : (Post_set_inputOptionalFields -> Post_set_inputOptionalFields) -> Post_set_input
buildPost_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, date = Absent, id = Absent, user_id = Absent }
    in
    { body = optionals.body, date = optionals.date, id = optionals.id, user_id = optionals.user_id }


type alias Post_set_inputOptionalFields =
    { body : OptionalArgument String
    , date : OptionalArgument CustomScalars.Date
    , id : OptionalArgument CustomScalars.Uuid
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Post\_set\_input input object.
-}
type alias Post_set_input =
    { body : OptionalArgument String
    , date : OptionalArgument CustomScalars.Date
    , id : OptionalArgument CustomScalars.Uuid
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Encode a Post\_set\_input into a value that can be used as an argument.
-}
encodePost_set_input : Post_set_input -> Value
encodePost_set_input input =
    Encode.maybeObject
        [ ( "body", Encode.string |> Encode.optional input.body ), ( "date", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date ), ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "user_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.user_id ) ]


buildPost_tag_aggregate_order_by : (Post_tag_aggregate_order_byOptionalFields -> Post_tag_aggregate_order_byOptionalFields) -> Post_tag_aggregate_order_by
buildPost_tag_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Post_tag_aggregate_order_byOptionalFields =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Post_tag_max_order_by
    , min : OptionalArgument Post_tag_min_order_by
    }


{-| Type for the Post\_tag\_aggregate\_order\_by input object.
-}
type alias Post_tag_aggregate_order_by =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Post_tag_max_order_by
    , min : OptionalArgument Post_tag_min_order_by
    }


{-| Encode a Post\_tag\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodePost_tag_aggregate_order_by : Post_tag_aggregate_order_by -> Value
encodePost_tag_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodePost_tag_max_order_by |> Encode.optional input.max ), ( "min", encodePost_tag_min_order_by |> Encode.optional input.min ) ]


buildPost_tag_arr_rel_insert_input : Post_tag_arr_rel_insert_inputRequiredFields -> (Post_tag_arr_rel_insert_inputOptionalFields -> Post_tag_arr_rel_insert_inputOptionalFields) -> Post_tag_arr_rel_insert_input
buildPost_tag_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Post_tag_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Post_tag_arr_rel_insert_inputRequiredFields =
    { data : List Post_tag_insert_input }


type alias Post_tag_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Post_tag_on_conflict }


{-| Type alias for the `Post_tag_arr_rel_insert_input` attributes. Note that this type
needs to use the `Post_tag_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_arr_rel_insert_inputRaw =
    { data : List Post_tag_insert_input
    , on_conflict : OptionalArgument Post_tag_on_conflict
    }


{-| Type for the Post\_tag\_arr\_rel\_insert\_input input object.
-}
type Post_tag_arr_rel_insert_input
    = Post_tag_arr_rel_insert_input Post_tag_arr_rel_insert_inputRaw


{-| Encode a Post\_tag\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_tag_arr_rel_insert_input : Post_tag_arr_rel_insert_input -> Value
encodePost_tag_arr_rel_insert_input (Post_tag_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePost_tag_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodePost_tag_on_conflict |> Encode.optional input.on_conflict ) ]


buildPost_tag_bool_exp : (Post_tag_bool_expOptionalFields -> Post_tag_bool_expOptionalFields) -> Post_tag_bool_exp
buildPost_tag_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, postBypostId = Absent, post_id = Absent, tagBytagId = Absent, tag_id = Absent, userByuserId = Absent, user_id = Absent }
    in
    Post_tag_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, postBypostId = optionals.postBypostId, post_id = optionals.post_id, tagBytagId = optionals.tagBytagId, tag_id = optionals.tag_id, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Post_tag_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , not_ : OptionalArgument Post_tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , id : OptionalArgument Uuid_comparison_exp
    , postBypostId : OptionalArgument Post_bool_exp
    , post_id : OptionalArgument Uuid_comparison_exp
    , tagBytagId : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    , userByuserId : OptionalArgument User_bool_exp
    , user_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Post_tag_bool_exp` attributes. Note that this type
needs to use the `Post_tag_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , not_ : OptionalArgument Post_tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , id : OptionalArgument Uuid_comparison_exp
    , postBypostId : OptionalArgument Post_bool_exp
    , post_id : OptionalArgument Uuid_comparison_exp
    , tagBytagId : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    , userByuserId : OptionalArgument User_bool_exp
    , user_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Post\_tag\_bool\_exp input object.
-}
type Post_tag_bool_exp
    = Post_tag_bool_exp Post_tag_bool_expRaw


{-| Encode a Post\_tag\_bool\_exp into a value that can be used as an argument.
-}
encodePost_tag_bool_exp : Post_tag_bool_exp -> Value
encodePost_tag_bool_exp (Post_tag_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodePost_tag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePost_tag_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePost_tag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "postBypostId", encodePost_bool_exp |> Encode.optional input.postBypostId ), ( "post_id", encodeUuid_comparison_exp |> Encode.optional input.post_id ), ( "tagBytagId", encodeTag_bool_exp |> Encode.optional input.tagBytagId ), ( "tag_id", encodeUuid_comparison_exp |> Encode.optional input.tag_id ), ( "userByuserId", encodeUser_bool_exp |> Encode.optional input.userByuserId ), ( "user_id", encodeUuid_comparison_exp |> Encode.optional input.user_id ) ]


buildPost_tag_insert_input : (Post_tag_insert_inputOptionalFields -> Post_tag_insert_inputOptionalFields) -> Post_tag_insert_input
buildPost_tag_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, postBypostId = Absent, post_id = Absent, tagBytagId = Absent, tag_id = Absent, userByuserId = Absent, user_id = Absent }
    in
    Post_tag_insert_input { id = optionals.id, postBypostId = optionals.postBypostId, post_id = optionals.post_id, tagBytagId = optionals.tagBytagId, tag_id = optionals.tag_id, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Post_tag_insert_inputOptionalFields =
    { id : OptionalArgument CustomScalars.Uuid
    , postBypostId : OptionalArgument Post_obj_rel_insert_input
    , post_id : OptionalArgument CustomScalars.Uuid
    , tagBytagId : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument CustomScalars.Uuid
    , userByuserId : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type alias for the `Post_tag_insert_input` attributes. Note that this type
needs to use the `Post_tag_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_insert_inputRaw =
    { id : OptionalArgument CustomScalars.Uuid
    , postBypostId : OptionalArgument Post_obj_rel_insert_input
    , post_id : OptionalArgument CustomScalars.Uuid
    , tagBytagId : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument CustomScalars.Uuid
    , userByuserId : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Post\_tag\_insert\_input input object.
-}
type Post_tag_insert_input
    = Post_tag_insert_input Post_tag_insert_inputRaw


{-| Encode a Post\_tag\_insert\_input into a value that can be used as an argument.
-}
encodePost_tag_insert_input : Post_tag_insert_input -> Value
encodePost_tag_insert_input (Post_tag_insert_input input) =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "postBypostId", encodePost_obj_rel_insert_input |> Encode.optional input.postBypostId ), ( "post_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.post_id ), ( "tagBytagId", encodeTag_obj_rel_insert_input |> Encode.optional input.tagBytagId ), ( "tag_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.tag_id ), ( "userByuserId", encodeUser_obj_rel_insert_input |> Encode.optional input.userByuserId ), ( "user_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.user_id ) ]


buildPost_tag_max_order_by : (Post_tag_max_order_byOptionalFields -> Post_tag_max_order_byOptionalFields) -> Post_tag_max_order_by
buildPost_tag_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, post_id = Absent, tag_id = Absent, user_id = Absent }
    in
    { id = optionals.id, post_id = optionals.post_id, tag_id = optionals.tag_id, user_id = optionals.user_id }


type alias Post_tag_max_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_tag\_max\_order\_by input object.
-}
type alias Post_tag_max_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Post\_tag\_max\_order\_by into a value that can be used as an argument.
-}
encodePost_tag_max_order_by : Post_tag_max_order_by -> Value
encodePost_tag_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "post_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.post_id ), ( "tag_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.tag_id ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildPost_tag_min_order_by : (Post_tag_min_order_byOptionalFields -> Post_tag_min_order_byOptionalFields) -> Post_tag_min_order_by
buildPost_tag_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, post_id = Absent, tag_id = Absent, user_id = Absent }
    in
    { id = optionals.id, post_id = optionals.post_id, tag_id = optionals.tag_id, user_id = optionals.user_id }


type alias Post_tag_min_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_tag\_min\_order\_by input object.
-}
type alias Post_tag_min_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Post\_tag\_min\_order\_by into a value that can be used as an argument.
-}
encodePost_tag_min_order_by : Post_tag_min_order_by -> Value
encodePost_tag_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "post_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.post_id ), ( "tag_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.tag_id ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildPost_tag_obj_rel_insert_input : Post_tag_obj_rel_insert_inputRequiredFields -> (Post_tag_obj_rel_insert_inputOptionalFields -> Post_tag_obj_rel_insert_inputOptionalFields) -> Post_tag_obj_rel_insert_input
buildPost_tag_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Post_tag_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Post_tag_obj_rel_insert_inputRequiredFields =
    { data : Post_tag_insert_input }


type alias Post_tag_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Post_tag_on_conflict }


{-| Type alias for the `Post_tag_obj_rel_insert_input` attributes. Note that this type
needs to use the `Post_tag_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_obj_rel_insert_inputRaw =
    { data : Post_tag_insert_input
    , on_conflict : OptionalArgument Post_tag_on_conflict
    }


{-| Type for the Post\_tag\_obj\_rel\_insert\_input input object.
-}
type Post_tag_obj_rel_insert_input
    = Post_tag_obj_rel_insert_input Post_tag_obj_rel_insert_inputRaw


{-| Encode a Post\_tag\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_tag_obj_rel_insert_input : Post_tag_obj_rel_insert_input -> Value
encodePost_tag_obj_rel_insert_input (Post_tag_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePost_tag_insert_input input.data |> Just ), ( "on_conflict", encodePost_tag_on_conflict |> Encode.optional input.on_conflict ) ]


buildPost_tag_on_conflict : Post_tag_on_conflictRequiredFields -> (Post_tag_on_conflictOptionalFields -> Post_tag_on_conflictOptionalFields) -> Post_tag_on_conflict
buildPost_tag_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Post_tag_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Post_tag_on_conflictRequiredFields =
    { constraint : Api.Enum.Post_tag_constraint.Post_tag_constraint
    , update_columns : List Api.Enum.Post_tag_update_column.Post_tag_update_column
    }


type alias Post_tag_on_conflictOptionalFields =
    { where_ : OptionalArgument Post_tag_bool_exp }


{-| Type alias for the `Post_tag_on_conflict` attributes. Note that this type
needs to use the `Post_tag_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_on_conflictRaw =
    { constraint : Api.Enum.Post_tag_constraint.Post_tag_constraint
    , update_columns : List Api.Enum.Post_tag_update_column.Post_tag_update_column
    , where_ : OptionalArgument Post_tag_bool_exp
    }


{-| Type for the Post\_tag\_on\_conflict input object.
-}
type Post_tag_on_conflict
    = Post_tag_on_conflict Post_tag_on_conflictRaw


{-| Encode a Post\_tag\_on\_conflict into a value that can be used as an argument.
-}
encodePost_tag_on_conflict : Post_tag_on_conflict -> Value
encodePost_tag_on_conflict (Post_tag_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Post_tag_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Post_tag_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodePost_tag_bool_exp |> Encode.optional input.where_ ) ]


buildPost_tag_order_by : (Post_tag_order_byOptionalFields -> Post_tag_order_byOptionalFields) -> Post_tag_order_by
buildPost_tag_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, postBypostId = Absent, post_id = Absent, tagBytagId = Absent, tag_id = Absent, userByuserId = Absent, user_id = Absent }
    in
    Post_tag_order_by { id = optionals.id, postBypostId = optionals.postBypostId, post_id = optionals.post_id, tagBytagId = optionals.tagBytagId, tag_id = optionals.tag_id, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Post_tag_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , postBypostId : OptionalArgument Post_order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tagBytagId : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    , userByuserId : OptionalArgument User_order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type alias for the `Post_tag_order_by` attributes. Note that this type
needs to use the `Post_tag_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_order_byRaw =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , postBypostId : OptionalArgument Post_order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tagBytagId : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    , userByuserId : OptionalArgument User_order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_tag\_order\_by input object.
-}
type Post_tag_order_by
    = Post_tag_order_by Post_tag_order_byRaw


{-| Encode a Post\_tag\_order\_by into a value that can be used as an argument.
-}
encodePost_tag_order_by : Post_tag_order_by -> Value
encodePost_tag_order_by (Post_tag_order_by input) =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "postBypostId", encodePost_order_by |> Encode.optional input.postBypostId ), ( "post_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.post_id ), ( "tagBytagId", encodeTag_order_by |> Encode.optional input.tagBytagId ), ( "tag_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.tag_id ), ( "userByuserId", encodeUser_order_by |> Encode.optional input.userByuserId ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildPost_tag_pk_columns_input : Post_tag_pk_columns_inputRequiredFields -> Post_tag_pk_columns_input
buildPost_tag_pk_columns_input required =
    { id = required.id }


type alias Post_tag_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the Post\_tag\_pk\_columns\_input input object.
-}
type alias Post_tag_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a Post\_tag\_pk\_columns\_input into a value that can be used as an argument.
-}
encodePost_tag_pk_columns_input : Post_tag_pk_columns_input -> Value
encodePost_tag_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildPost_tag_set_input : (Post_tag_set_inputOptionalFields -> Post_tag_set_inputOptionalFields) -> Post_tag_set_input
buildPost_tag_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, post_id = Absent, tag_id = Absent, user_id = Absent }
    in
    { id = optionals.id, post_id = optionals.post_id, tag_id = optionals.tag_id, user_id = optionals.user_id }


type alias Post_tag_set_inputOptionalFields =
    { id : OptionalArgument CustomScalars.Uuid
    , post_id : OptionalArgument CustomScalars.Uuid
    , tag_id : OptionalArgument CustomScalars.Uuid
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Post\_tag\_set\_input input object.
-}
type alias Post_tag_set_input =
    { id : OptionalArgument CustomScalars.Uuid
    , post_id : OptionalArgument CustomScalars.Uuid
    , tag_id : OptionalArgument CustomScalars.Uuid
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Encode a Post\_tag\_set\_input into a value that can be used as an argument.
-}
encodePost_tag_set_input : Post_tag_set_input -> Value
encodePost_tag_set_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "post_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.post_id ), ( "tag_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.tag_id ), ( "user_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.user_id ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTag_aggregate_order_by : (Tag_aggregate_order_byOptionalFields -> Tag_aggregate_order_byOptionalFields) -> Tag_aggregate_order_by
buildTag_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Tag_aggregate_order_byOptionalFields =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Tag_max_order_by
    , min : OptionalArgument Tag_min_order_by
    }


{-| Type for the Tag\_aggregate\_order\_by input object.
-}
type alias Tag_aggregate_order_by =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Tag_max_order_by
    , min : OptionalArgument Tag_min_order_by
    }


{-| Encode a Tag\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTag_aggregate_order_by : Tag_aggregate_order_by -> Value
encodeTag_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeTag_max_order_by |> Encode.optional input.max ), ( "min", encodeTag_min_order_by |> Encode.optional input.min ) ]


buildTag_arr_rel_insert_input : Tag_arr_rel_insert_inputRequiredFields -> (Tag_arr_rel_insert_inputOptionalFields -> Tag_arr_rel_insert_inputOptionalFields) -> Tag_arr_rel_insert_input
buildTag_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Tag_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Tag_arr_rel_insert_inputRequiredFields =
    { data : List Tag_insert_input }


type alias Tag_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Tag_on_conflict }


{-| Type alias for the `Tag_arr_rel_insert_input` attributes. Note that this type
needs to use the `Tag_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_arr_rel_insert_inputRaw =
    { data : List Tag_insert_input
    , on_conflict : OptionalArgument Tag_on_conflict
    }


{-| Type for the Tag\_arr\_rel\_insert\_input input object.
-}
type Tag_arr_rel_insert_input
    = Tag_arr_rel_insert_input Tag_arr_rel_insert_inputRaw


{-| Encode a Tag\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTag_arr_rel_insert_input : Tag_arr_rel_insert_input -> Value
encodeTag_arr_rel_insert_input (Tag_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeTag_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeTag_on_conflict |> Encode.optional input.on_conflict ) ]


buildTag_bool_exp : (Tag_bool_expOptionalFields -> Tag_bool_expOptionalFields) -> Tag_bool_exp
buildTag_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, name = Absent, postTagsBytagId = Absent, userByuserId = Absent, user_id = Absent }
    in
    Tag_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, name = optionals.name, postTagsBytagId = optionals.postTagsBytagId, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Tag_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , not_ : OptionalArgument Tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , postTagsBytagId : OptionalArgument Post_tag_bool_exp
    , userByuserId : OptionalArgument User_bool_exp
    , user_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Tag_bool_exp` attributes. Note that this type
needs to use the `Tag_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , not_ : OptionalArgument Tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , postTagsBytagId : OptionalArgument Post_tag_bool_exp
    , userByuserId : OptionalArgument User_bool_exp
    , user_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Tag\_bool\_exp input object.
-}
type Tag_bool_exp
    = Tag_bool_exp Tag_bool_expRaw


{-| Encode a Tag\_bool\_exp into a value that can be used as an argument.
-}
encodeTag_bool_exp : Tag_bool_exp -> Value
encodeTag_bool_exp (Tag_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTag_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ), ( "postTagsBytagId", encodePost_tag_bool_exp |> Encode.optional input.postTagsBytagId ), ( "userByuserId", encodeUser_bool_exp |> Encode.optional input.userByuserId ), ( "user_id", encodeUuid_comparison_exp |> Encode.optional input.user_id ) ]


buildTag_insert_input : (Tag_insert_inputOptionalFields -> Tag_insert_inputOptionalFields) -> Tag_insert_input
buildTag_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, postTagsBytagId = Absent, userByuserId = Absent, user_id = Absent }
    in
    Tag_insert_input { id = optionals.id, name = optionals.name, postTagsBytagId = optionals.postTagsBytagId, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Tag_insert_inputOptionalFields =
    { id : OptionalArgument CustomScalars.Uuid
    , name : OptionalArgument String
    , postTagsBytagId : OptionalArgument Post_tag_arr_rel_insert_input
    , userByuserId : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type alias for the `Tag_insert_input` attributes. Note that this type
needs to use the `Tag_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_insert_inputRaw =
    { id : OptionalArgument CustomScalars.Uuid
    , name : OptionalArgument String
    , postTagsBytagId : OptionalArgument Post_tag_arr_rel_insert_input
    , userByuserId : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Tag\_insert\_input input object.
-}
type Tag_insert_input
    = Tag_insert_input Tag_insert_inputRaw


{-| Encode a Tag\_insert\_input into a value that can be used as an argument.
-}
encodeTag_insert_input : Tag_insert_input -> Value
encodeTag_insert_input (Tag_insert_input input) =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "postTagsBytagId", encodePost_tag_arr_rel_insert_input |> Encode.optional input.postTagsBytagId ), ( "userByuserId", encodeUser_obj_rel_insert_input |> Encode.optional input.userByuserId ), ( "user_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.user_id ) ]


buildTag_max_order_by : (Tag_max_order_byOptionalFields -> Tag_max_order_byOptionalFields) -> Tag_max_order_by
buildTag_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, user_id = Absent }
    in
    { id = optionals.id, name = optionals.name, user_id = optionals.user_id }


type alias Tag_max_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_max\_order\_by input object.
-}
type alias Tag_max_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Tag\_max\_order\_by into a value that can be used as an argument.
-}
encodeTag_max_order_by : Tag_max_order_by -> Value
encodeTag_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTag_min_order_by : (Tag_min_order_byOptionalFields -> Tag_min_order_byOptionalFields) -> Tag_min_order_by
buildTag_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, user_id = Absent }
    in
    { id = optionals.id, name = optionals.name, user_id = optionals.user_id }


type alias Tag_min_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_min\_order\_by input object.
-}
type alias Tag_min_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Tag\_min\_order\_by into a value that can be used as an argument.
-}
encodeTag_min_order_by : Tag_min_order_by -> Value
encodeTag_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTag_obj_rel_insert_input : Tag_obj_rel_insert_inputRequiredFields -> (Tag_obj_rel_insert_inputOptionalFields -> Tag_obj_rel_insert_inputOptionalFields) -> Tag_obj_rel_insert_input
buildTag_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Tag_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Tag_obj_rel_insert_inputRequiredFields =
    { data : Tag_insert_input }


type alias Tag_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Tag_on_conflict }


{-| Type alias for the `Tag_obj_rel_insert_input` attributes. Note that this type
needs to use the `Tag_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_obj_rel_insert_inputRaw =
    { data : Tag_insert_input
    , on_conflict : OptionalArgument Tag_on_conflict
    }


{-| Type for the Tag\_obj\_rel\_insert\_input input object.
-}
type Tag_obj_rel_insert_input
    = Tag_obj_rel_insert_input Tag_obj_rel_insert_inputRaw


{-| Encode a Tag\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTag_obj_rel_insert_input : Tag_obj_rel_insert_input -> Value
encodeTag_obj_rel_insert_input (Tag_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeTag_insert_input input.data |> Just ), ( "on_conflict", encodeTag_on_conflict |> Encode.optional input.on_conflict ) ]


buildTag_on_conflict : Tag_on_conflictRequiredFields -> (Tag_on_conflictOptionalFields -> Tag_on_conflictOptionalFields) -> Tag_on_conflict
buildTag_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Tag_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Tag_on_conflictRequiredFields =
    { constraint : Api.Enum.Tag_constraint.Tag_constraint
    , update_columns : List Api.Enum.Tag_update_column.Tag_update_column
    }


type alias Tag_on_conflictOptionalFields =
    { where_ : OptionalArgument Tag_bool_exp }


{-| Type alias for the `Tag_on_conflict` attributes. Note that this type
needs to use the `Tag_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_on_conflictRaw =
    { constraint : Api.Enum.Tag_constraint.Tag_constraint
    , update_columns : List Api.Enum.Tag_update_column.Tag_update_column
    , where_ : OptionalArgument Tag_bool_exp
    }


{-| Type for the Tag\_on\_conflict input object.
-}
type Tag_on_conflict
    = Tag_on_conflict Tag_on_conflictRaw


{-| Encode a Tag\_on\_conflict into a value that can be used as an argument.
-}
encodeTag_on_conflict : Tag_on_conflict -> Value
encodeTag_on_conflict (Tag_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Tag_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Tag_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeTag_bool_exp |> Encode.optional input.where_ ) ]


buildTag_order_by : (Tag_order_byOptionalFields -> Tag_order_byOptionalFields) -> Tag_order_by
buildTag_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, postTagsBytagId_aggregate = Absent, userByuserId = Absent, user_id = Absent }
    in
    Tag_order_by { id = optionals.id, name = optionals.name, postTagsBytagId_aggregate = optionals.postTagsBytagId_aggregate, userByuserId = optionals.userByuserId, user_id = optionals.user_id }


type alias Tag_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , postTagsBytagId_aggregate : OptionalArgument Post_tag_aggregate_order_by
    , userByuserId : OptionalArgument User_order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type alias for the `Tag_order_by` attributes. Note that this type
needs to use the `Tag_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_order_byRaw =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , postTagsBytagId_aggregate : OptionalArgument Post_tag_aggregate_order_by
    , userByuserId : OptionalArgument User_order_by
    , user_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_order\_by input object.
-}
type Tag_order_by
    = Tag_order_by Tag_order_byRaw


{-| Encode a Tag\_order\_by into a value that can be used as an argument.
-}
encodeTag_order_by : Tag_order_by -> Value
encodeTag_order_by (Tag_order_by input) =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ), ( "postTagsBytagId_aggregate", encodePost_tag_aggregate_order_by |> Encode.optional input.postTagsBytagId_aggregate ), ( "userByuserId", encodeUser_order_by |> Encode.optional input.userByuserId ), ( "user_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTag_pk_columns_input : Tag_pk_columns_inputRequiredFields -> Tag_pk_columns_input
buildTag_pk_columns_input required =
    { id = required.id }


type alias Tag_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the Tag\_pk\_columns\_input input object.
-}
type alias Tag_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a Tag\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTag_pk_columns_input : Tag_pk_columns_input -> Value
encodeTag_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildTag_set_input : (Tag_set_inputOptionalFields -> Tag_set_inputOptionalFields) -> Tag_set_input
buildTag_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, user_id = Absent }
    in
    { id = optionals.id, name = optionals.name, user_id = optionals.user_id }


type alias Tag_set_inputOptionalFields =
    { id : OptionalArgument CustomScalars.Uuid
    , name : OptionalArgument String
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Tag\_set\_input input object.
-}
type alias Tag_set_input =
    { id : OptionalArgument CustomScalars.Uuid
    , name : OptionalArgument String
    , user_id : OptionalArgument CustomScalars.Uuid
    }


{-| Encode a Tag\_set\_input into a value that can be used as an argument.
-}
encodeTag_set_input : Tag_set_input -> Value
encodeTag_set_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "user_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.user_id ) ]


buildUser_aggregate_order_by : (User_aggregate_order_byOptionalFields -> User_aggregate_order_byOptionalFields) -> User_aggregate_order_by
buildUser_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias User_aggregate_order_byOptionalFields =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument User_max_order_by
    , min : OptionalArgument User_min_order_by
    }


{-| Type for the User\_aggregate\_order\_by input object.
-}
type alias User_aggregate_order_by =
    { count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument User_max_order_by
    , min : OptionalArgument User_min_order_by
    }


{-| Encode a User\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeUser_aggregate_order_by : User_aggregate_order_by -> Value
encodeUser_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeUser_max_order_by |> Encode.optional input.max ), ( "min", encodeUser_min_order_by |> Encode.optional input.min ) ]


buildUser_arr_rel_insert_input : User_arr_rel_insert_inputRequiredFields -> (User_arr_rel_insert_inputOptionalFields -> User_arr_rel_insert_inputOptionalFields) -> User_arr_rel_insert_input
buildUser_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    User_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias User_arr_rel_insert_inputRequiredFields =
    { data : List User_insert_input }


type alias User_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_arr_rel_insert_input` attributes. Note that this type
needs to use the `User_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_arr_rel_insert_inputRaw =
    { data : List User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_arr\_rel\_insert\_input input object.
-}
type User_arr_rel_insert_input
    = User_arr_rel_insert_input User_arr_rel_insert_inputRaw


{-| Encode a User\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_arr_rel_insert_input : User_arr_rel_insert_input -> Value
encodeUser_arr_rel_insert_input (User_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeUser_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input.on_conflict ) ]


buildUser_bool_exp : (User_bool_expOptionalFields -> User_bool_expOptionalFields) -> User_bool_exp
buildUser_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, email = Absent, id = Absent, nonce = Absent, password = Absent, postTagsByuserId = Absent, postsByuserId = Absent, tagsByuserId = Absent }
    in
    User_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, email = optionals.email, id = optionals.id, nonce = optionals.nonce, password = optionals.password, postTagsByuserId = optionals.postTagsByuserId, postsByuserId = optionals.postsByuserId, tagsByuserId = optionals.tagsByuserId }


type alias User_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe User_bool_exp))
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List (Maybe User_bool_exp))
    , email : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , nonce : OptionalArgument String_comparison_exp
    , password : OptionalArgument String_comparison_exp
    , postTagsByuserId : OptionalArgument Post_tag_bool_exp
    , postsByuserId : OptionalArgument Post_bool_exp
    , tagsByuserId : OptionalArgument Tag_bool_exp
    }


{-| Type alias for the `User_bool_exp` attributes. Note that this type
needs to use the `User_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe User_bool_exp))
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List (Maybe User_bool_exp))
    , email : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , nonce : OptionalArgument String_comparison_exp
    , password : OptionalArgument String_comparison_exp
    , postTagsByuserId : OptionalArgument Post_tag_bool_exp
    , postsByuserId : OptionalArgument Post_bool_exp
    , tagsByuserId : OptionalArgument Tag_bool_exp
    }


{-| Type for the User\_bool\_exp input object.
-}
type User_bool_exp
    = User_bool_exp User_bool_expRaw


{-| Encode a User\_bool\_exp into a value that can be used as an argument.
-}
encodeUser_bool_exp : User_bool_exp -> Value
encodeUser_bool_exp (User_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUser_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUser_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUser_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "email", encodeString_comparison_exp |> Encode.optional input.email ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "nonce", encodeString_comparison_exp |> Encode.optional input.nonce ), ( "password", encodeString_comparison_exp |> Encode.optional input.password ), ( "postTagsByuserId", encodePost_tag_bool_exp |> Encode.optional input.postTagsByuserId ), ( "postsByuserId", encodePost_bool_exp |> Encode.optional input.postsByuserId ), ( "tagsByuserId", encodeTag_bool_exp |> Encode.optional input.tagsByuserId ) ]


buildUser_insert_input : (User_insert_inputOptionalFields -> User_insert_inputOptionalFields) -> User_insert_input
buildUser_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, id = Absent, nonce = Absent, password = Absent, postTagsByuserId = Absent, postsByuserId = Absent, tagsByuserId = Absent }
    in
    User_insert_input { email = optionals.email, id = optionals.id, nonce = optionals.nonce, password = optionals.password, postTagsByuserId = optionals.postTagsByuserId, postsByuserId = optionals.postsByuserId, tagsByuserId = optionals.tagsByuserId }


type alias User_insert_inputOptionalFields =
    { email : OptionalArgument String
    , id : OptionalArgument CustomScalars.Uuid
    , nonce : OptionalArgument String
    , password : OptionalArgument String
    , postTagsByuserId : OptionalArgument Post_tag_arr_rel_insert_input
    , postsByuserId : OptionalArgument Post_arr_rel_insert_input
    , tagsByuserId : OptionalArgument Tag_arr_rel_insert_input
    }


{-| Type alias for the `User_insert_input` attributes. Note that this type
needs to use the `User_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_insert_inputRaw =
    { email : OptionalArgument String
    , id : OptionalArgument CustomScalars.Uuid
    , nonce : OptionalArgument String
    , password : OptionalArgument String
    , postTagsByuserId : OptionalArgument Post_tag_arr_rel_insert_input
    , postsByuserId : OptionalArgument Post_arr_rel_insert_input
    , tagsByuserId : OptionalArgument Tag_arr_rel_insert_input
    }


{-| Type for the User\_insert\_input input object.
-}
type User_insert_input
    = User_insert_input User_insert_inputRaw


{-| Encode a User\_insert\_input into a value that can be used as an argument.
-}
encodeUser_insert_input : User_insert_input -> Value
encodeUser_insert_input (User_insert_input input) =
    Encode.maybeObject
        [ ( "email", Encode.string |> Encode.optional input.email ), ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "nonce", Encode.string |> Encode.optional input.nonce ), ( "password", Encode.string |> Encode.optional input.password ), ( "postTagsByuserId", encodePost_tag_arr_rel_insert_input |> Encode.optional input.postTagsByuserId ), ( "postsByuserId", encodePost_arr_rel_insert_input |> Encode.optional input.postsByuserId ), ( "tagsByuserId", encodeTag_arr_rel_insert_input |> Encode.optional input.tagsByuserId ) ]


buildUser_max_order_by : (User_max_order_byOptionalFields -> User_max_order_byOptionalFields) -> User_max_order_by
buildUser_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, id = Absent, nonce = Absent, password = Absent }
    in
    { email = optionals.email, id = optionals.id, nonce = optionals.nonce, password = optionals.password }


type alias User_max_order_byOptionalFields =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , nonce : OptionalArgument Api.Enum.Order_by.Order_by
    , password : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the User\_max\_order\_by input object.
-}
type alias User_max_order_by =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , nonce : OptionalArgument Api.Enum.Order_by.Order_by
    , password : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a User\_max\_order\_by into a value that can be used as an argument.
-}
encodeUser_max_order_by : User_max_order_by -> Value
encodeUser_max_order_by input =
    Encode.maybeObject
        [ ( "email", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.email ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "nonce", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.nonce ), ( "password", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.password ) ]


buildUser_min_order_by : (User_min_order_byOptionalFields -> User_min_order_byOptionalFields) -> User_min_order_by
buildUser_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, id = Absent, nonce = Absent, password = Absent }
    in
    { email = optionals.email, id = optionals.id, nonce = optionals.nonce, password = optionals.password }


type alias User_min_order_byOptionalFields =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , nonce : OptionalArgument Api.Enum.Order_by.Order_by
    , password : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the User\_min\_order\_by input object.
-}
type alias User_min_order_by =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , nonce : OptionalArgument Api.Enum.Order_by.Order_by
    , password : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a User\_min\_order\_by into a value that can be used as an argument.
-}
encodeUser_min_order_by : User_min_order_by -> Value
encodeUser_min_order_by input =
    Encode.maybeObject
        [ ( "email", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.email ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "nonce", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.nonce ), ( "password", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.password ) ]


buildUser_obj_rel_insert_input : User_obj_rel_insert_inputRequiredFields -> (User_obj_rel_insert_inputOptionalFields -> User_obj_rel_insert_inputOptionalFields) -> User_obj_rel_insert_input
buildUser_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    User_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias User_obj_rel_insert_inputRequiredFields =
    { data : User_insert_input }


type alias User_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_obj_rel_insert_input` attributes. Note that this type
needs to use the `User_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_obj_rel_insert_inputRaw =
    { data : User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_obj\_rel\_insert\_input input object.
-}
type User_obj_rel_insert_input
    = User_obj_rel_insert_input User_obj_rel_insert_inputRaw


{-| Encode a User\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_obj_rel_insert_input : User_obj_rel_insert_input -> Value
encodeUser_obj_rel_insert_input (User_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeUser_insert_input input.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input.on_conflict ) ]


buildUser_on_conflict : User_on_conflictRequiredFields -> (User_on_conflictOptionalFields -> User_on_conflictOptionalFields) -> User_on_conflict
buildUser_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    User_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias User_on_conflictRequiredFields =
    { constraint : Api.Enum.User_constraint.User_constraint
    , update_columns : List Api.Enum.User_update_column.User_update_column
    }


type alias User_on_conflictOptionalFields =
    { where_ : OptionalArgument User_bool_exp }


{-| Type alias for the `User_on_conflict` attributes. Note that this type
needs to use the `User_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_on_conflictRaw =
    { constraint : Api.Enum.User_constraint.User_constraint
    , update_columns : List Api.Enum.User_update_column.User_update_column
    , where_ : OptionalArgument User_bool_exp
    }


{-| Type for the User\_on\_conflict input object.
-}
type User_on_conflict
    = User_on_conflict User_on_conflictRaw


{-| Encode a User\_on\_conflict into a value that can be used as an argument.
-}
encodeUser_on_conflict : User_on_conflict -> Value
encodeUser_on_conflict (User_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.User_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.User_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeUser_bool_exp |> Encode.optional input.where_ ) ]


buildUser_order_by : (User_order_byOptionalFields -> User_order_byOptionalFields) -> User_order_by
buildUser_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, id = Absent, nonce = Absent, password = Absent, postTagsByuserId_aggregate = Absent, postsByuserId_aggregate = Absent, tagsByuserId_aggregate = Absent }
    in
    { email = optionals.email, id = optionals.id, nonce = optionals.nonce, password = optionals.password, postTagsByuserId_aggregate = optionals.postTagsByuserId_aggregate, postsByuserId_aggregate = optionals.postsByuserId_aggregate, tagsByuserId_aggregate = optionals.tagsByuserId_aggregate }


type alias User_order_byOptionalFields =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , nonce : OptionalArgument Api.Enum.Order_by.Order_by
    , password : OptionalArgument Api.Enum.Order_by.Order_by
    , postTagsByuserId_aggregate : OptionalArgument Post_tag_aggregate_order_by
    , postsByuserId_aggregate : OptionalArgument Post_aggregate_order_by
    , tagsByuserId_aggregate : OptionalArgument Tag_aggregate_order_by
    }


{-| Type for the User\_order\_by input object.
-}
type alias User_order_by =
    { email : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , nonce : OptionalArgument Api.Enum.Order_by.Order_by
    , password : OptionalArgument Api.Enum.Order_by.Order_by
    , postTagsByuserId_aggregate : OptionalArgument Post_tag_aggregate_order_by
    , postsByuserId_aggregate : OptionalArgument Post_aggregate_order_by
    , tagsByuserId_aggregate : OptionalArgument Tag_aggregate_order_by
    }


{-| Encode a User\_order\_by into a value that can be used as an argument.
-}
encodeUser_order_by : User_order_by -> Value
encodeUser_order_by input =
    Encode.maybeObject
        [ ( "email", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.email ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "nonce", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.nonce ), ( "password", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.password ), ( "postTagsByuserId_aggregate", encodePost_tag_aggregate_order_by |> Encode.optional input.postTagsByuserId_aggregate ), ( "postsByuserId_aggregate", encodePost_aggregate_order_by |> Encode.optional input.postsByuserId_aggregate ), ( "tagsByuserId_aggregate", encodeTag_aggregate_order_by |> Encode.optional input.tagsByuserId_aggregate ) ]


buildUser_pk_columns_input : User_pk_columns_inputRequiredFields -> User_pk_columns_input
buildUser_pk_columns_input required =
    { id = required.id }


type alias User_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the User\_pk\_columns\_input input object.
-}
type alias User_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a User\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeUser_pk_columns_input : User_pk_columns_input -> Value
encodeUser_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildUser_set_input : (User_set_inputOptionalFields -> User_set_inputOptionalFields) -> User_set_input
buildUser_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, id = Absent, nonce = Absent, password = Absent }
    in
    { email = optionals.email, id = optionals.id, nonce = optionals.nonce, password = optionals.password }


type alias User_set_inputOptionalFields =
    { email : OptionalArgument String
    , id : OptionalArgument CustomScalars.Uuid
    , nonce : OptionalArgument String
    , password : OptionalArgument String
    }


{-| Type for the User\_set\_input input object.
-}
type alias User_set_input =
    { email : OptionalArgument String
    , id : OptionalArgument CustomScalars.Uuid
    , nonce : OptionalArgument String
    , password : OptionalArgument String
    }


{-| Encode a User\_set\_input into a value that can be used as an argument.
-}
encodeUser_set_input : User_set_input -> Value
encodeUser_set_input input =
    Encode.maybeObject
        [ ( "email", Encode.string |> Encode.optional input.email ), ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "nonce", Encode.string |> Encode.optional input.nonce ), ( "password", Encode.string |> Encode.optional input.password ) ]


buildUuid_comparison_exp : (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields) -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalars.Uuid
    , gt_ : OptionalArgument CustomScalars.Uuid
    , gte_ : OptionalArgument CustomScalars.Uuid
    , in_ : OptionalArgument (List CustomScalars.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Uuid
    , lte_ : OptionalArgument CustomScalars.Uuid
    , neq_ : OptionalArgument CustomScalars.Uuid
    , nin_ : OptionalArgument (List CustomScalars.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument CustomScalars.Uuid
    , gt_ : OptionalArgument CustomScalars.Uuid
    , gte_ : OptionalArgument CustomScalars.Uuid
    , in_ : OptionalArgument (List CustomScalars.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Uuid
    , lte_ : OptionalArgument CustomScalars.Uuid
    , neq_ : OptionalArgument CustomScalars.Uuid
    , nin_ : OptionalArgument (List CustomScalars.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]
