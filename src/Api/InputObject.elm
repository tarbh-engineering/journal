-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (..)

import Api.Enum.Order_by
import Api.Enum.Post_constraint
import Api.Enum.Post_update_column
import Api.Enum.Tag_constraint
import Api.Enum.Tag_update_column
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import CustomScalars
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildDate_comparison_exp :
    (Date_comparison_expOptionalFields -> Date_comparison_expOptionalFields)
    -> Date_comparison_exp
buildDate_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Date_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalars.Date
    , gt_ : OptionalArgument CustomScalars.Date
    , gte_ : OptionalArgument CustomScalars.Date
    , in_ : OptionalArgument (List CustomScalars.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Date
    , lte_ : OptionalArgument CustomScalars.Date
    , neq_ : OptionalArgument CustomScalars.Date
    , nin_ : OptionalArgument (List CustomScalars.Date)
    }


{-| Type for the Date\_comparison\_exp input object.
-}
type alias Date_comparison_exp =
    { eq_ : OptionalArgument CustomScalars.Date
    , gt_ : OptionalArgument CustomScalars.Date
    , gte_ : OptionalArgument CustomScalars.Date
    , in_ : OptionalArgument (List CustomScalars.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Date
    , lte_ : OptionalArgument CustomScalars.Date
    , neq_ : OptionalArgument CustomScalars.Date
    , nin_ : OptionalArgument (List CustomScalars.Date)
    }


{-| Encode a Date\_comparison\_exp into a value that can be used as an argument.
-}
encodeDate_comparison_exp : Date_comparison_exp -> Value
encodeDate_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildPost_arr_rel_insert_input :
    Post_arr_rel_insert_inputRequiredFields
    -> (Post_arr_rel_insert_inputOptionalFields -> Post_arr_rel_insert_inputOptionalFields)
    -> Post_arr_rel_insert_input
buildPost_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Post_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Post_arr_rel_insert_inputRequiredFields =
    { data : List Post_insert_input }


type alias Post_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Post_on_conflict }


{-| Type alias for the `Post_arr_rel_insert_input` attributes. Note that this type
needs to use the `Post_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_arr_rel_insert_inputRaw =
    { data : List Post_insert_input
    , on_conflict : OptionalArgument Post_on_conflict
    }


{-| Type for the Post\_arr\_rel\_insert\_input input object.
-}
type Post_arr_rel_insert_input
    = Post_arr_rel_insert_input Post_arr_rel_insert_inputRaw


{-| Encode a Post\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_arr_rel_insert_input : Post_arr_rel_insert_input -> Value
encodePost_arr_rel_insert_input (Post_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePost_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodePost_on_conflict |> Encode.optional input.on_conflict ) ]


buildPost_bool_exp :
    (Post_bool_expOptionalFields -> Post_bool_expOptionalFields)
    -> Post_bool_exp
buildPost_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, ciphertext = Absent, date = Absent, id = Absent, iv = Absent, post_tags = Absent }
    in
    Post_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, ciphertext = optionals.ciphertext, date = optionals.date, id = optionals.id, iv = optionals.iv, post_tags = optionals.post_tags }


type alias Post_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Post_bool_exp))
    , not_ : OptionalArgument Post_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_bool_exp))
    , ciphertext : OptionalArgument String_comparison_exp
    , date : OptionalArgument Date_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , iv : OptionalArgument String_comparison_exp
    , post_tags : OptionalArgument Post_tag_bool_exp
    }


{-| Type alias for the `Post_bool_exp` attributes. Note that this type
needs to use the `Post_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Post_bool_exp))
    , not_ : OptionalArgument Post_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_bool_exp))
    , ciphertext : OptionalArgument String_comparison_exp
    , date : OptionalArgument Date_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , iv : OptionalArgument String_comparison_exp
    , post_tags : OptionalArgument Post_tag_bool_exp
    }


{-| Type for the Post\_bool\_exp input object.
-}
type Post_bool_exp
    = Post_bool_exp Post_bool_expRaw


{-| Encode a Post\_bool\_exp into a value that can be used as an argument.
-}
encodePost_bool_exp : Post_bool_exp -> Value
encodePost_bool_exp (Post_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodePost_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePost_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePost_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "ciphertext", encodeString_comparison_exp |> Encode.optional input.ciphertext ), ( "date", encodeDate_comparison_exp |> Encode.optional input.date ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "iv", encodeString_comparison_exp |> Encode.optional input.iv ), ( "post_tags", encodePost_tag_bool_exp |> Encode.optional input.post_tags ) ]


buildPost_insert_input :
    (Post_insert_inputOptionalFields -> Post_insert_inputOptionalFields)
    -> Post_insert_input
buildPost_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { ciphertext = Absent, date = Absent, iv = Absent, post_tags = Absent }
    in
    Post_insert_input { ciphertext = optionals.ciphertext, date = optionals.date, iv = optionals.iv, post_tags = optionals.post_tags }


type alias Post_insert_inputOptionalFields =
    { ciphertext : OptionalArgument String
    , date : OptionalArgument CustomScalars.Date
    , iv : OptionalArgument String
    , post_tags : OptionalArgument Post_tag_arr_rel_insert_input
    }


{-| Type alias for the `Post_insert_input` attributes. Note that this type
needs to use the `Post_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_insert_inputRaw =
    { ciphertext : OptionalArgument String
    , date : OptionalArgument CustomScalars.Date
    , iv : OptionalArgument String
    , post_tags : OptionalArgument Post_tag_arr_rel_insert_input
    }


{-| Type for the Post\_insert\_input input object.
-}
type Post_insert_input
    = Post_insert_input Post_insert_inputRaw


{-| Encode a Post\_insert\_input into a value that can be used as an argument.
-}
encodePost_insert_input : Post_insert_input -> Value
encodePost_insert_input (Post_insert_input input) =
    Encode.maybeObject
        [ ( "ciphertext", Encode.string |> Encode.optional input.ciphertext ), ( "date", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.date ), ( "iv", Encode.string |> Encode.optional input.iv ), ( "post_tags", encodePost_tag_arr_rel_insert_input |> Encode.optional input.post_tags ) ]


buildPost_obj_rel_insert_input :
    Post_obj_rel_insert_inputRequiredFields
    -> (Post_obj_rel_insert_inputOptionalFields -> Post_obj_rel_insert_inputOptionalFields)
    -> Post_obj_rel_insert_input
buildPost_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Post_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Post_obj_rel_insert_inputRequiredFields =
    { data : Post_insert_input }


type alias Post_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Post_on_conflict }


{-| Type alias for the `Post_obj_rel_insert_input` attributes. Note that this type
needs to use the `Post_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_obj_rel_insert_inputRaw =
    { data : Post_insert_input
    , on_conflict : OptionalArgument Post_on_conflict
    }


{-| Type for the Post\_obj\_rel\_insert\_input input object.
-}
type Post_obj_rel_insert_input
    = Post_obj_rel_insert_input Post_obj_rel_insert_inputRaw


{-| Encode a Post\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_obj_rel_insert_input : Post_obj_rel_insert_input -> Value
encodePost_obj_rel_insert_input (Post_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePost_insert_input input.data |> Just ), ( "on_conflict", encodePost_on_conflict |> Encode.optional input.on_conflict ) ]


buildPost_on_conflict :
    Post_on_conflictRequiredFields
    -> (Post_on_conflictOptionalFields -> Post_on_conflictOptionalFields)
    -> Post_on_conflict
buildPost_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Post_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Post_on_conflictRequiredFields =
    { constraint : Api.Enum.Post_constraint.Post_constraint
    , update_columns : List Api.Enum.Post_update_column.Post_update_column
    }


type alias Post_on_conflictOptionalFields =
    { where_ : OptionalArgument Post_bool_exp }


{-| Type alias for the `Post_on_conflict` attributes. Note that this type
needs to use the `Post_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_on_conflictRaw =
    { constraint : Api.Enum.Post_constraint.Post_constraint
    , update_columns : List Api.Enum.Post_update_column.Post_update_column
    , where_ : OptionalArgument Post_bool_exp
    }


{-| Type for the Post\_on\_conflict input object.
-}
type Post_on_conflict
    = Post_on_conflict Post_on_conflictRaw


{-| Encode a Post\_on\_conflict into a value that can be used as an argument.
-}
encodePost_on_conflict : Post_on_conflict -> Value
encodePost_on_conflict (Post_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Post_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Post_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodePost_bool_exp |> Encode.optional input.where_ ) ]


buildPost_order_by :
    (Post_order_byOptionalFields -> Post_order_byOptionalFields)
    -> Post_order_by
buildPost_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { ciphertext = Absent, date = Absent, id = Absent, iv = Absent }
    in
    { ciphertext = optionals.ciphertext, date = optionals.date, id = optionals.id, iv = optionals.iv }


type alias Post_order_byOptionalFields =
    { ciphertext : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , iv : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_order\_by input object.
-}
type alias Post_order_by =
    { ciphertext : OptionalArgument Api.Enum.Order_by.Order_by
    , date : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , iv : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Post\_order\_by into a value that can be used as an argument.
-}
encodePost_order_by : Post_order_by -> Value
encodePost_order_by input =
    Encode.maybeObject
        [ ( "ciphertext", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.ciphertext ), ( "date", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.date ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "iv", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.iv ) ]


buildPost_pk_columns_input :
    Post_pk_columns_inputRequiredFields
    -> Post_pk_columns_input
buildPost_pk_columns_input required =
    { id = required.id }


type alias Post_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the Post\_pk\_columns\_input input object.
-}
type alias Post_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a Post\_pk\_columns\_input into a value that can be used as an argument.
-}
encodePost_pk_columns_input : Post_pk_columns_input -> Value
encodePost_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildPost_set_input :
    (Post_set_inputOptionalFields -> Post_set_inputOptionalFields)
    -> Post_set_input
buildPost_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { ciphertext = Absent, iv = Absent }
    in
    { ciphertext = optionals.ciphertext, iv = optionals.iv }


type alias Post_set_inputOptionalFields =
    { ciphertext : OptionalArgument String
    , iv : OptionalArgument String
    }


{-| Type for the Post\_set\_input input object.
-}
type alias Post_set_input =
    { ciphertext : OptionalArgument String
    , iv : OptionalArgument String
    }


{-| Encode a Post\_set\_input into a value that can be used as an argument.
-}
encodePost_set_input : Post_set_input -> Value
encodePost_set_input input =
    Encode.maybeObject
        [ ( "ciphertext", Encode.string |> Encode.optional input.ciphertext ), ( "iv", Encode.string |> Encode.optional input.iv ) ]


buildPost_tag_arr_rel_insert_input :
    Post_tag_arr_rel_insert_inputRequiredFields
    -> Post_tag_arr_rel_insert_input
buildPost_tag_arr_rel_insert_input required =
    Post_tag_arr_rel_insert_input { data = required.data }


type alias Post_tag_arr_rel_insert_inputRequiredFields =
    { data : List Post_tag_insert_input }


{-| Type alias for the `Post_tag_arr_rel_insert_input` attributes. Note that this type
needs to use the `Post_tag_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_arr_rel_insert_inputRaw =
    { data : List Post_tag_insert_input }


{-| Type for the Post\_tag\_arr\_rel\_insert\_input input object.
-}
type Post_tag_arr_rel_insert_input
    = Post_tag_arr_rel_insert_input Post_tag_arr_rel_insert_inputRaw


{-| Encode a Post\_tag\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_tag_arr_rel_insert_input : Post_tag_arr_rel_insert_input -> Value
encodePost_tag_arr_rel_insert_input (Post_tag_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodePost_tag_insert_input |> Encode.list) input.data |> Just ) ]


buildPost_tag_bool_exp :
    (Post_tag_bool_expOptionalFields -> Post_tag_bool_expOptionalFields)
    -> Post_tag_bool_exp
buildPost_tag_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, post = Absent, post_id = Absent, tag = Absent, tag_id = Absent }
    in
    Post_tag_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, post = optionals.post, post_id = optionals.post_id, tag = optionals.tag, tag_id = optionals.tag_id }


type alias Post_tag_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , not_ : OptionalArgument Post_tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , id : OptionalArgument Uuid_comparison_exp
    , post : OptionalArgument Post_bool_exp
    , post_id : OptionalArgument Uuid_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Post_tag_bool_exp` attributes. Note that this type
needs to use the `Post_tag_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , not_ : OptionalArgument Post_tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Post_tag_bool_exp))
    , id : OptionalArgument Uuid_comparison_exp
    , post : OptionalArgument Post_bool_exp
    , post_id : OptionalArgument Uuid_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Post\_tag\_bool\_exp input object.
-}
type Post_tag_bool_exp
    = Post_tag_bool_exp Post_tag_bool_expRaw


{-| Encode a Post\_tag\_bool\_exp into a value that can be used as an argument.
-}
encodePost_tag_bool_exp : Post_tag_bool_exp -> Value
encodePost_tag_bool_exp (Post_tag_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodePost_tag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePost_tag_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePost_tag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "post", encodePost_bool_exp |> Encode.optional input.post ), ( "post_id", encodeUuid_comparison_exp |> Encode.optional input.post_id ), ( "tag", encodeTag_bool_exp |> Encode.optional input.tag ), ( "tag_id", encodeUuid_comparison_exp |> Encode.optional input.tag_id ) ]


buildPost_tag_insert_input :
    (Post_tag_insert_inputOptionalFields -> Post_tag_insert_inputOptionalFields)
    -> Post_tag_insert_input
buildPost_tag_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { post = Absent, post_id = Absent, tag = Absent, tag_id = Absent }
    in
    Post_tag_insert_input { post = optionals.post, post_id = optionals.post_id, tag = optionals.tag, tag_id = optionals.tag_id }


type alias Post_tag_insert_inputOptionalFields =
    { post : OptionalArgument Post_obj_rel_insert_input
    , post_id : OptionalArgument CustomScalars.Uuid
    , tag : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type alias for the `Post_tag_insert_input` attributes. Note that this type
needs to use the `Post_tag_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_insert_inputRaw =
    { post : OptionalArgument Post_obj_rel_insert_input
    , post_id : OptionalArgument CustomScalars.Uuid
    , tag : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument CustomScalars.Uuid
    }


{-| Type for the Post\_tag\_insert\_input input object.
-}
type Post_tag_insert_input
    = Post_tag_insert_input Post_tag_insert_inputRaw


{-| Encode a Post\_tag\_insert\_input into a value that can be used as an argument.
-}
encodePost_tag_insert_input : Post_tag_insert_input -> Value
encodePost_tag_insert_input (Post_tag_insert_input input) =
    Encode.maybeObject
        [ ( "post", encodePost_obj_rel_insert_input |> Encode.optional input.post ), ( "post_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.post_id ), ( "tag", encodeTag_obj_rel_insert_input |> Encode.optional input.tag ), ( "tag_id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.tag_id ) ]


buildPost_tag_obj_rel_insert_input :
    Post_tag_obj_rel_insert_inputRequiredFields
    -> Post_tag_obj_rel_insert_input
buildPost_tag_obj_rel_insert_input required =
    Post_tag_obj_rel_insert_input { data = required.data }


type alias Post_tag_obj_rel_insert_inputRequiredFields =
    { data : Post_tag_insert_input }


{-| Type alias for the `Post_tag_obj_rel_insert_input` attributes. Note that this type
needs to use the `Post_tag_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Post_tag_obj_rel_insert_inputRaw =
    { data : Post_tag_insert_input }


{-| Type for the Post\_tag\_obj\_rel\_insert\_input input object.
-}
type Post_tag_obj_rel_insert_input
    = Post_tag_obj_rel_insert_input Post_tag_obj_rel_insert_inputRaw


{-| Encode a Post\_tag\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodePost_tag_obj_rel_insert_input : Post_tag_obj_rel_insert_input -> Value
encodePost_tag_obj_rel_insert_input (Post_tag_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodePost_tag_insert_input input.data |> Just ) ]


buildPost_tag_order_by :
    (Post_tag_order_byOptionalFields -> Post_tag_order_byOptionalFields)
    -> Post_tag_order_by
buildPost_tag_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, post = Absent, post_id = Absent, tag = Absent, tag_id = Absent }
    in
    { id = optionals.id, post = optionals.post, post_id = optionals.post_id, tag = optionals.tag, tag_id = optionals.tag_id }


type alias Post_tag_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , post : OptionalArgument Post_order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tag : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Post\_tag\_order\_by input object.
-}
type alias Post_tag_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by
    , post : OptionalArgument Post_order_by
    , post_id : OptionalArgument Api.Enum.Order_by.Order_by
    , tag : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Post\_tag\_order\_by into a value that can be used as an argument.
-}
encodePost_tag_order_by : Post_tag_order_by -> Value
encodePost_tag_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "post", encodePost_order_by |> Encode.optional input.post ), ( "post_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.post_id ), ( "tag", encodeTag_order_by |> Encode.optional input.tag ), ( "tag_id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.tag_id ) ]


buildPost_tag_pk_columns_input :
    Post_tag_pk_columns_inputRequiredFields
    -> Post_tag_pk_columns_input
buildPost_tag_pk_columns_input required =
    { id = required.id }


type alias Post_tag_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the Post\_tag\_pk\_columns\_input input object.
-}
type alias Post_tag_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a Post\_tag\_pk\_columns\_input into a value that can be used as an argument.
-}
encodePost_tag_pk_columns_input : Post_tag_pk_columns_input -> Value
encodePost_tag_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTag_arr_rel_insert_input :
    Tag_arr_rel_insert_inputRequiredFields
    -> (Tag_arr_rel_insert_inputOptionalFields -> Tag_arr_rel_insert_inputOptionalFields)
    -> Tag_arr_rel_insert_input
buildTag_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Tag_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Tag_arr_rel_insert_inputRequiredFields =
    { data : List Tag_insert_input }


type alias Tag_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Tag_on_conflict }


{-| Type alias for the `Tag_arr_rel_insert_input` attributes. Note that this type
needs to use the `Tag_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_arr_rel_insert_inputRaw =
    { data : List Tag_insert_input
    , on_conflict : OptionalArgument Tag_on_conflict
    }


{-| Type for the Tag\_arr\_rel\_insert\_input input object.
-}
type Tag_arr_rel_insert_input
    = Tag_arr_rel_insert_input Tag_arr_rel_insert_inputRaw


{-| Encode a Tag\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTag_arr_rel_insert_input : Tag_arr_rel_insert_input -> Value
encodeTag_arr_rel_insert_input (Tag_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeTag_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeTag_on_conflict |> Encode.optional input.on_conflict ) ]


buildTag_bool_exp :
    (Tag_bool_expOptionalFields -> Tag_bool_expOptionalFields)
    -> Tag_bool_exp
buildTag_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, ciphertext = Absent, created_at = Absent, id = Absent, iv = Absent, post_tags = Absent }
    in
    Tag_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, ciphertext = optionals.ciphertext, created_at = optionals.created_at, id = optionals.id, iv = optionals.iv, post_tags = optionals.post_tags }


type alias Tag_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , not_ : OptionalArgument Tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , ciphertext : OptionalArgument String_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , iv : OptionalArgument String_comparison_exp
    , post_tags : OptionalArgument Post_tag_bool_exp
    }


{-| Type alias for the `Tag_bool_exp` attributes. Note that this type
needs to use the `Tag_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , not_ : OptionalArgument Tag_bool_exp
    , or_ : OptionalArgument (List (Maybe Tag_bool_exp))
    , ciphertext : OptionalArgument String_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , iv : OptionalArgument String_comparison_exp
    , post_tags : OptionalArgument Post_tag_bool_exp
    }


{-| Type for the Tag\_bool\_exp input object.
-}
type Tag_bool_exp
    = Tag_bool_exp Tag_bool_expRaw


{-| Encode a Tag\_bool\_exp into a value that can be used as an argument.
-}
encodeTag_bool_exp : Tag_bool_exp -> Value
encodeTag_bool_exp (Tag_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTag_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTag_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "ciphertext", encodeString_comparison_exp |> Encode.optional input.ciphertext ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "iv", encodeString_comparison_exp |> Encode.optional input.iv ), ( "post_tags", encodePost_tag_bool_exp |> Encode.optional input.post_tags ) ]


buildTag_insert_input :
    (Tag_insert_inputOptionalFields -> Tag_insert_inputOptionalFields)
    -> Tag_insert_input
buildTag_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { ciphertext = Absent, iv = Absent, post_tags = Absent }
    in
    Tag_insert_input { ciphertext = optionals.ciphertext, iv = optionals.iv, post_tags = optionals.post_tags }


type alias Tag_insert_inputOptionalFields =
    { ciphertext : OptionalArgument String
    , iv : OptionalArgument String
    , post_tags : OptionalArgument Post_tag_arr_rel_insert_input
    }


{-| Type alias for the `Tag_insert_input` attributes. Note that this type
needs to use the `Tag_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_insert_inputRaw =
    { ciphertext : OptionalArgument String
    , iv : OptionalArgument String
    , post_tags : OptionalArgument Post_tag_arr_rel_insert_input
    }


{-| Type for the Tag\_insert\_input input object.
-}
type Tag_insert_input
    = Tag_insert_input Tag_insert_inputRaw


{-| Encode a Tag\_insert\_input into a value that can be used as an argument.
-}
encodeTag_insert_input : Tag_insert_input -> Value
encodeTag_insert_input (Tag_insert_input input) =
    Encode.maybeObject
        [ ( "ciphertext", Encode.string |> Encode.optional input.ciphertext ), ( "iv", Encode.string |> Encode.optional input.iv ), ( "post_tags", encodePost_tag_arr_rel_insert_input |> Encode.optional input.post_tags ) ]


buildTag_obj_rel_insert_input :
    Tag_obj_rel_insert_inputRequiredFields
    -> (Tag_obj_rel_insert_inputOptionalFields -> Tag_obj_rel_insert_inputOptionalFields)
    -> Tag_obj_rel_insert_input
buildTag_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Tag_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Tag_obj_rel_insert_inputRequiredFields =
    { data : Tag_insert_input }


type alias Tag_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Tag_on_conflict }


{-| Type alias for the `Tag_obj_rel_insert_input` attributes. Note that this type
needs to use the `Tag_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_obj_rel_insert_inputRaw =
    { data : Tag_insert_input
    , on_conflict : OptionalArgument Tag_on_conflict
    }


{-| Type for the Tag\_obj\_rel\_insert\_input input object.
-}
type Tag_obj_rel_insert_input
    = Tag_obj_rel_insert_input Tag_obj_rel_insert_inputRaw


{-| Encode a Tag\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTag_obj_rel_insert_input : Tag_obj_rel_insert_input -> Value
encodeTag_obj_rel_insert_input (Tag_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeTag_insert_input input.data |> Just ), ( "on_conflict", encodeTag_on_conflict |> Encode.optional input.on_conflict ) ]


buildTag_on_conflict :
    Tag_on_conflictRequiredFields
    -> (Tag_on_conflictOptionalFields -> Tag_on_conflictOptionalFields)
    -> Tag_on_conflict
buildTag_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Tag_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Tag_on_conflictRequiredFields =
    { constraint : Api.Enum.Tag_constraint.Tag_constraint
    , update_columns : List Api.Enum.Tag_update_column.Tag_update_column
    }


type alias Tag_on_conflictOptionalFields =
    { where_ : OptionalArgument Tag_bool_exp }


{-| Type alias for the `Tag_on_conflict` attributes. Note that this type
needs to use the `Tag_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_on_conflictRaw =
    { constraint : Api.Enum.Tag_constraint.Tag_constraint
    , update_columns : List Api.Enum.Tag_update_column.Tag_update_column
    , where_ : OptionalArgument Tag_bool_exp
    }


{-| Type for the Tag\_on\_conflict input object.
-}
type Tag_on_conflict
    = Tag_on_conflict Tag_on_conflictRaw


{-| Encode a Tag\_on\_conflict into a value that can be used as an argument.
-}
encodeTag_on_conflict : Tag_on_conflict -> Value
encodeTag_on_conflict (Tag_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Tag_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Tag_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeTag_bool_exp |> Encode.optional input.where_ ) ]


buildTag_order_by :
    (Tag_order_byOptionalFields -> Tag_order_byOptionalFields)
    -> Tag_order_by
buildTag_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { ciphertext = Absent, created_at = Absent, id = Absent, iv = Absent }
    in
    { ciphertext = optionals.ciphertext, created_at = optionals.created_at, id = optionals.id, iv = optionals.iv }


type alias Tag_order_byOptionalFields =
    { ciphertext : OptionalArgument Api.Enum.Order_by.Order_by
    , created_at : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , iv : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_order\_by input object.
-}
type alias Tag_order_by =
    { ciphertext : OptionalArgument Api.Enum.Order_by.Order_by
    , created_at : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , iv : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Tag\_order\_by into a value that can be used as an argument.
-}
encodeTag_order_by : Tag_order_by -> Value
encodeTag_order_by input =
    Encode.maybeObject
        [ ( "ciphertext", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.ciphertext ), ( "created_at", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "iv", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.iv ) ]


buildTag_pk_columns_input :
    Tag_pk_columns_inputRequiredFields
    -> Tag_pk_columns_input
buildTag_pk_columns_input required =
    { id = required.id }


type alias Tag_pk_columns_inputRequiredFields =
    { id : CustomScalars.Uuid }


{-| Type for the Tag\_pk\_columns\_input input object.
-}
type alias Tag_pk_columns_input =
    { id : CustomScalars.Uuid }


{-| Encode a Tag\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTag_pk_columns_input : Tag_pk_columns_input -> Value
encodeTag_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) input.id |> Just ) ]


buildTag_set_input :
    (Tag_set_inputOptionalFields -> Tag_set_inputOptionalFields)
    -> Tag_set_input
buildTag_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { ciphertext = Absent, iv = Absent }
    in
    { ciphertext = optionals.ciphertext, iv = optionals.iv }


type alias Tag_set_inputOptionalFields =
    { ciphertext : OptionalArgument String
    , iv : OptionalArgument String
    }


{-| Type for the Tag\_set\_input input object.
-}
type alias Tag_set_input =
    { ciphertext : OptionalArgument String
    , iv : OptionalArgument String
    }


{-| Encode a Tag\_set\_input into a value that can be used as an argument.
-}
encodeTag_set_input : Tag_set_input -> Value
encodeTag_set_input input =
    Encode.maybeObject
        [ ( "ciphertext", Encode.string |> Encode.optional input.ciphertext ), ( "iv", Encode.string |> Encode.optional input.iv ) ]


buildTimestamptz_comparison_exp :
    (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields)
    -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalars.Timestamptz
    , gt_ : OptionalArgument CustomScalars.Timestamptz
    , gte_ : OptionalArgument CustomScalars.Timestamptz
    , in_ : OptionalArgument (List CustomScalars.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Timestamptz
    , lte_ : OptionalArgument CustomScalars.Timestamptz
    , neq_ : OptionalArgument CustomScalars.Timestamptz
    , nin_ : OptionalArgument (List CustomScalars.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument CustomScalars.Timestamptz
    , gt_ : OptionalArgument CustomScalars.Timestamptz
    , gte_ : OptionalArgument CustomScalars.Timestamptz
    , in_ : OptionalArgument (List CustomScalars.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Timestamptz
    , lte_ : OptionalArgument CustomScalars.Timestamptz
    , neq_ : OptionalArgument CustomScalars.Timestamptz
    , nin_ : OptionalArgument (List CustomScalars.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildUuid_comparison_exp :
    (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields)
    -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalars.Uuid
    , gt_ : OptionalArgument CustomScalars.Uuid
    , gte_ : OptionalArgument CustomScalars.Uuid
    , in_ : OptionalArgument (List CustomScalars.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Uuid
    , lte_ : OptionalArgument CustomScalars.Uuid
    , neq_ : OptionalArgument CustomScalars.Uuid
    , nin_ : OptionalArgument (List CustomScalars.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument CustomScalars.Uuid
    , gt_ : OptionalArgument CustomScalars.Uuid
    , gte_ : OptionalArgument CustomScalars.Uuid
    , in_ : OptionalArgument (List CustomScalars.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalars.Uuid
    , lte_ : OptionalArgument CustomScalars.Uuid
    , neq_ : OptionalArgument CustomScalars.Uuid
    , nin_ : OptionalArgument (List CustomScalars.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalars.codecs |> Api.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]
